/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./src/lib.js */ \"./src/lib.js\");\n\n\n//# sourceURL=webpack://raster/./index.js?");

/***/ }),

/***/ "./src/algorithm.js":
/*!**************************!*\
  !*** ./src/algorithm.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const palette = __webpack_require__(/*! ./palette.js */ \"./src/palette.js\");\nconst rgbColor = __webpack_require__(/*! ./rgb_color.js */ \"./src/rgb_color.js\");\nconst geometry = __webpack_require__(/*! ./geometry.js */ \"./src/geometry.js\");\nconst isInt = geometry.isInt;\n\nfunction midpointCircleRasterize(r) {\n  if (!r) {\n    return [];\n  }\n  // Only allow radius to be a whole number, or 0.5 more than a whole number.\n  r = Math.round(r * 2) / 2;\n  // Special case for some small circles, to make them look better.\n  if (r == 1.5) {\n    return [[1,0],[0,1]];\n  } else if (r == 3.0) {\n    return [[3,1],[2,2]];\n  } else if (r == 5.5) {\n    return [[5,0],[5,1],[4,2],[4,3]];\n  } else if (r == 7.0) {\n    return [[7,1],[7,2],[6,3],[6,4],[5,5]];\n  }\n  // Construct the arc.\n  let arc = new Array();\n  let y = 0;\n  let x = r;\n  let rSquared = r * r;\n  // Sample pixels from their center.\n  x -= 0.5;\n  if (isHalfwayValue(x)) {\n    y += 0.5;\n  }\n  let xSquared = x * x;\n  let ySquared = y * y;\n  // Loop increments Y each step, and decrements X occasionally, based upon\n  // error accumulation. Eventually X==Y, which breaks the loop.\n  while (true) {\n    // Invariant: x * x == xSquared && y * y == ySquared\n    let dist = xSquared + ySquared;\n    if (dist > rSquared) {\n      xSquared = xSquared - 2 * x + 1;\n      x -= 1;\n    }\n    if (x < y) {\n      break;\n    }\n    arc.push([Math.ceil(x), Math.ceil(y)])\n    ySquared = ySquared + 2 * y + 1;\n    y += 1;\n  }\n  return arc;\n}\n\nfunction color32BitToRGB(val) {\n  let rgb = Math.floor(val / 0x100);\n  let r = Math.floor(rgb / 0x10000) % 0x100;\n  let g = Math.floor(rgb / 0x100) % 0x100;\n  let b = Math.floor(rgb / 0x1) % 0x100;\n  return [r, g, b];\n}\n\nfunction color24BitToRGB(val) {\n  let rgb = val;\n  let r = Math.floor(rgb / 0x10000) % 0x100;\n  let g = Math.floor(rgb / 0x100) % 0x100;\n  let b = Math.floor(rgb / 1) % 0x100;\n  return [r, g, b];\n}\n\nfunction isHalfwayValue(num) {\n  let fract = num - Math.floor(num);\n  return fract >= 0.25 && fract < 0.75;\n}\n\nfunction rgbToHSV(r, g, b) {\n  let m = Math.max(r, g, b)\n  let n = Math.min(r, g, b)\n  let d = m - n\n  let h = 0\n  let s = (m == 0) ? 0 : (d / m)\n  let v = m / 255\n  if (m == r) {\n    h = (g - b) + d * (g < b ? 6 : 0)\n  } else if (m == g) {\n    h = (b - r) + d * 2\n  } else if (m == b) {\n    h = (r - g) + d * 4\n  }\n  if (h != 0) {\n    h = h / (6 * d)\n  }\n  return [h, s, v]\n}\n\nfunction sortByHSV(items) {\n  for (let i = 0; i < items.length; i++) {\n    let it = items[i];\n    if (it.constructor != rgbColor.RGBColor) {\n      throw new Error('sortByHSV got invalid item[${i}] must be RGBColor');\n    }\n  }\n  // Build a list of colors, weighted by HSV\n  let colors = [];\n  for (let i = 0; i < items.length; i++) {\n    let rgb = items[i];\n    let [h, s, v] = rgbToHSV(rgb.r, rgb.g, rgb.b);\n    let k = Math.floor(h * 10) * 10000 + Math.floor(v * 1000) + s;\n    colors.push({key: k, rgb: rgb});\n  }\n  // Sort those colors\n  colors.sort(function(a, b) {\n    if (a.key < b.key) { return -1; }\n    if (a.key > b.key) { return 1; }\n    return 0;\n  });\n\n  // Convert back to just rgb values\n  let build = [];\n  for (let j = 0; j < colors.length; j++) {\n    let rgb = colors[j].rgb;\n    build.push(rgb);\n  }\n  return build;\n}\n\nfunction flood(mem, initX, initY, color) {\n  let target = mem[initY*mem.pitch+initX];\n  let queue = [{x:initX,y:initY}];\n  let i = 0;\n  while (queue.length > 0) {\n    let node = queue.shift();\n    // Inside?\n    let value = mem[node.y*mem.pitch+node.x];\n    if (value != target) {\n      continue;\n    }\n    mem[node.y*mem.pitch+node.x] = color;\n    // West\n    if (node.x > 0) {\n      queue.push({x:node.x-1, y:node.y});\n    }\n    // North\n    if (node.y > 0) {\n      queue.push({x:node.x, y:node.y-1});\n    }\n    // East\n    if (node.x < mem.x_dim - 1) {\n      queue.push({x:node.x+1, y:node.y});\n    }\n    // South\n    if (node.y < mem.y_dim - 1) {\n      queue.push({x:node.x, y:node.y+1});\n    }\n  }\n}\n\nfunction renderLine(plane, x0, y0, x1, y1, connectCorners) {\n  if (!isInt(x0) || !isInt(y0) || !isInt(x1) || !isInt(y1)) {\n    return renderLineFloat(plane, x0, y0, x1, y1);\n  }\n\n  // Integer based line drawing\n  let put = [];\n  let deltax = x1 - x0;\n  let deltay = y1 - y0;\n\n  if (Math.abs(deltay) <= Math.abs(deltax)) {\n\n    if (deltax < 0) {\n      [x0, x1] = [x1, x0];\n      [y0, y1] = [y1, y0];\n      deltax = -deltax;\n      deltay = -deltay;\n    }\n\n    if (connectCorners) {\n      if (deltay >= 0) {\n        deltay++;\n      } else {\n        deltay--;\n      }\n    }\n\n    let dist = 2 * Math.abs(deltay) - deltax;\n    if (connectCorners) {\n      dist = 2 * Math.abs(deltay) - 2 * deltax;\n    }\n\n    let y = y0;\n    for (let x = x0; x <= x1; x++) {\n      // Draw a pixel\n      if (x >= 0 && x < plane.width && y >= 0 && y < plane.height) {\n        put.push([x, y]);\n      }\n\n      if (dist > 0) {\n        if (deltay > 0) {\n          y = y + 1;\n        } else if (deltay < 0) {\n          y = y - 1;\n        }\n        dist = dist - 2*deltax;\n      }\n      dist = dist + 2*Math.abs(deltay);\n    }\n  } else {\n\n    if (deltay < 0) {\n      [x0, x1] = [x1, x0];\n      [y0, y1] = [y1, y0];\n      deltax = -deltax;\n      deltay = -deltay;\n    }\n\n    if (connectCorners) {\n      if (deltax >= 0) {\n        deltax++;\n      } else {\n        deltax--;\n      }\n    }\n\n    let dist = 2 * Math.abs(deltax) - deltay;\n    if (connectCorners) {\n      dist = 2 * Math.abs(deltax) - 2 * deltay;\n    }\n    let x = x0;\n    for (let y = y0; y <= y1; y++) {\n      // Draw a pixel\n      if (x >= 0 && x < plane.width && y >= 0 && y < plane.height) {\n        put.push([x, y]);\n      }\n\n      if (dist > 0) {\n        if (deltax > 0) {\n          x = x + 1;\n        } else if (deltax < 0) {\n          x = x - 1;\n        }\n        dist = dist - 2*deltay;\n      }\n      dist = dist + 2*Math.abs(deltax);\n    }\n  }\n\n  return put;\n}\n\nfunction renderLineFloat(plane, x0, y0, x1, y1) {\n  let put = [];\n  let deltax = x1 - x0;\n  let deltay = y1 - y0;\n  let slope = deltay / deltax;\n  let positiveTorque = 1;\n\n  if (Math.abs(deltay) <= Math.abs(deltax)) {\n    // Always draw left to right. If backwards, swap the endpoints.\n    if (deltax < 0) {\n      [x0, x1] = [x1, x0];\n      [y0, y1] = [y1, y0];\n      deltax = -deltax;\n      deltay = -deltay;\n      positiveTorque = 0;\n    }\n    // Iterate each X pixel until we reach the endpoint.\n    let midpoint, intercept;\n    let limit = Math.ceil(x1);\n    let x, y;\n    x = Math.floor(x0);\n\n    if (fract(x0) > 0.5) {\n      x += 1;\n    }\n    if (fract(x1) > 0.0 && fract(x1) < 0.5) {\n      limit -= 1;\n    }\n\n    for (; x < limit; x++) {\n      midpoint = x + 0.5;\n      intercept = (midpoint - x0) * slope + y0;\n      y = Math.floor(intercept);\n      if (fract(intercept) == 0.0 && !positiveTorque) {\n        // Handle rounding depending on the torque of the line draw.\n        y -= 1;\n      }\n      put.push([x, y]);\n    }\n  } else {\n    if (deltay < 0) {\n      [x0, x1] = [x1, x0];\n      [y0, y1] = [y1, y0];\n      deltax = -deltax;\n      deltay = -deltay;\n      positiveTorque = 0;\n    }\n    // Iterate each Y pixel until we reach the endpoint.\n    let midpoint, intercept;\n    let limit = Math.ceil(y1);\n    let x, y;\n    y = Math.floor(y0);\n\n    if (fract(y0) > 0.5) {\n      y += 1;\n    }\n    if (fract(y1) > 0.0 && fract(y1) < 0.5) {\n      limit -= 1;\n    }\n\n    for (; y < limit; y++) {\n      midpoint = y + 0.5;\n      intercept = (midpoint - y0) / slope + x0;\n      x = Math.floor(intercept);\n      if (fract(intercept) == 0.0 && !positiveTorque) {\n        // Handle rounding depending on the torque of the line draw.\n        x -= 1;\n      }\n      put.push([x, y]);\n    }\n  }\n\n  return put;\n}\n\nfunction fract(n) {\n  return n - Math.floor(n);\n}\n\nfunction renderPolygon(plane, baseX, baseY, inPoints, fill) {\n  let isPixelPoly = geometry.isInt(baseX) && geometry.isInt(baseY);\n  let points = [];\n  for (let i = 0; i < inPoints.length; i++) {\n    let p = inPoints[i];\n    if (!geometry.isInt(p[0]) || !geometry.isInt(p[1])) {\n      isPixelPoly = false;\n    }\n    points.push({x: p[0] + baseX, y: p[1] + baseY});\n  }\n  if (fill) {\n    return renderPolygonFill(plane, points, isPixelPoly);\n  } else {\n    return renderPolygonOutline(plane, points, isPixelPoly);\n  }\n}\n\nfunction asFloats(points) {\n  let result = [];\n  for (let i = 0; i < points.length; i++) {\n    let p = points[i];\n    result.push({x: p.x + 0.5000001, y: p.y + 0.5000001});\n  }\n  return result;\n}\n\nfunction renderPolygonFill(plane, inPoints, isPixelPoly) {\n  let put = [];\n  let edgeX = [];\n  let edgeDir = [];\n  let pixelX, pixelY;\n  let i, j;\n  let lineSegYi, lineSegYj, lineSegXi, lineSegXj;\n\n  let points;\n  if (isPixelPoly) {\n    points = asFloats(inPoints);\n  } else {\n    points = inPoints;\n  }\n\n  let imageTop, imageBottom;\n  let imageLeft, imageRight;\n  imageTop = points[0].y;\n  imageBottom = points[0].y;\n  imageLeft = points[0].x;\n  imageRight = points[0].x;\n\n  // Find polygon's top and bottom.\n  for (let i = 1; i < points.length; i++) {\n    if (points[i].x < imageLeft) {\n      imageLeft = points[i].x;\n    }\n    if (points[i].x > imageRight) {\n      imageRight = points[i].x;\n    }\n    if (points[i].y < imageTop) {\n      imageTop = points[i].y;\n    }\n    if (points[i].y > imageBottom) {\n      imageBottom = points[i].y;\n    }\n  }\n\n  let y0 = Math.floor(imageTop);\n  let y1 = Math.floor(imageBottom);\n  if (y0 < 0) {\n    y0 = 0;\n  }\n  if (y1 >= plane.height) {\n    y1 = plane.height - 1;\n  }\n\n  //  Loop through the rows of the image.\n  for (pixelY = Math.floor(imageTop); pixelY <= imageBottom; pixelY++) {\n    let scanlineY = pixelY + 0.5;\n\n    edgeX = [];\n    edgeDir = [];\n\n    // Build a list of edges\n    for (i = 0; i < points.length; i++) {\n      if (i > 0) {\n        j = i - 1;\n      } else {\n        j = points.length - 1;\n      }\n      lineSegXi = points[i].x;\n      lineSegXj = points[j].x;\n      lineSegYi = points[i].y;\n      lineSegYj = points[j].y;\n\n      // If the current scanline's Y position overlaps the line segment.\n      if ((lineSegYi <= scanlineY && lineSegYj >= scanlineY) ||\n          (lineSegYj <= scanlineY && lineSegYi >= scanlineY)) {\n\n        if (lineSegYi == lineSegYj) {\n          continue;\n        }\n\n        // Calculate where the edge intersects the scanline.\n        let deltaX = lineSegXj - lineSegXi;\n        let deltaY = lineSegYj - lineSegYi;\n        let slope = (scanlineY-lineSegYi)/deltaY*deltaX;\n        let intersect = Math.floor(lineSegXi + slope);\n        let lineDirY = deltaY >= 0 ? 1 : -1;\n\n        // If edge is already intersecting this pixel, and this edge\n        // is going in the same direction, skip adding it.\n        if (edgeX.length > 0) {\n          let last = edgeX.length - 1;\n          if (edgeX[last] == intersect && edgeDir[last] == lineDirY) {\n            continue;\n          }\n          if (edgeX[0] == intersect && edgeDir[0] == lineDirY) {\n            continue;\n          }\n        }\n\n        // Add the edge intersection.\n        edgeX.push(intersect);\n        edgeDir.push(lineDirY);\n      }\n    }\n\n    // Sort the edges, via a simple bubble sort.\n    if (edgeX.length > 0) {\n      i = 0;\n      while (i < edgeX.length - 1) {\n        if (edgeX[i] > edgeX[i+1]) {\n          let tmp = edgeX[i];\n          edgeX[i] = edgeX[i+1];\n          edgeX[i+1] = tmp;\n          if (i) {\n            i--;\n          }\n        } else {\n          i++;\n        }\n      }\n    }\n\n    // Fill the pixels between the edges.\n    for (i = 0; i < edgeX.length; i += 2) {\n      let x0 = Math.floor(edgeX[i]);\n      let x1 = Math.floor(edgeX[i+1]);\n      if (x0 < 0) {\n        x0 = 0;\n      }\n      if (x1 >= plane.width) {\n        x1 = plane.width - 1;\n      }\n      let y = Math.floor(pixelY);\n      put.push([x0, x1, y, y]);\n    }\n  }\n\n  // TODO: Handle fractional edges such that this call isn't needed.\n  let res = renderPolygonOutline(plane, inPoints);\n  put = put.concat(res);\n  return put;\n}\n\nfunction renderPolygonOutline(plane, points) {\n  let put = [];\n  let i, j;\n\n  for (i = 0; i < points.length; i++) {\n    if (i > 0) {\n      j = i - 1;\n    } else {\n      j = points.length - 1;\n    }\n    let p = points[i];\n    let q = points[j];\n    let res = renderLine(plane, p.x, p.y, q.x, q.y, false);\n    put = put.concat(res);\n  }\n\n  return put;\n}\n\nfunction renderCircle(x, y, points, inner, fill, half) {\n  let put = [];\n\n  // Num points will always be assigned, but num inner is optional.\n  let numPoints = points.length;\n  let numInner = inner ? inner.length : -1;\n\n  for (let i = 0; i < numPoints; i++) {\n    let pair = points[i];\n\n    // The circle is defined by an arc that represents one octant of the\n    // full circle. This arc is a list of int pairs. One is called the stretch\n    // and begins equal to the radius, then moves occassional back towards\n    // the origin as it moves around the circumfrence. The other is called\n    // the cross, and moves laterally away from the origin, monotonically at\n    // end step.\n    //\n    // For example:\n    //\n    //           arc\n    //            |\n    //            v\n    //           \\    ^\n    //            |   |\n    //             \\  | <- cross\n    //              | |\n    //              | |\n    // ------------->\n    //        ^\n    //        |\n    //     stretch\n    //\n    // In this case, the total stretch = 13, and the total cross = 5.\n    // The arc is this list of ints: [[13,0],[13,1],[12,2],[12,3],[11,4]]\n\n    let stretch = pair[0];\n    let cross = pair[1];\n\n    let limit = -1;\n    if (i < numInner) {\n      // If inner list exists, and we're inside it, get the Left value.\n      pair = inner[i];\n      limit = pair[0];\n    } else if (numInner != -1) {\n      // If inner list exists, and we're past it, Left is the diagonal border.\n      limit = cross - 2;\n    }\n\n    // Handle the difference between far values (those going in a positive\n    // direction), and near values (those going in a negative direction),\n    // when the circle radius is at a halfway value. This is needed in order\n    // to give the circle the proper width.\n    let adjustFar = 0;\n    if (!half) {\n      adjustFar = 1;\n    }\n    // Far stretch, near stretch, far cross, and near cross.\n    let fars = stretch - adjustFar;\n    let nears = -stretch;\n    let farc = cross - adjustFar;\n    let nearc = -cross;\n\n    // Far limit, and near limit.\n    let farl = 0;\n    let nearl = 0;\n    if (fill) {\n      // When filling the circle, put the range completely to the origin.\n      farl = 0;\n      nearl = 0;\n    } else if (limit == -1) {\n      // If no width given, set a width of 1\n      farl = stretch - adjustFar;\n      nearl = -stretch;\n    } else {\n      // If a width was given, use a range limit.\n      farl = limit - adjustFar;\n      nearl = -limit;\n    }\n\n    // Call putRange, and draw the appropriate mirrored octant of the arc\n    // in order to draw the complete the circle. Numbered as follows:\n    //\n    //            2    |    1\n    //             \\   |   /\n    //              |  |  |\n    //               \\ | /\n    //   3 ____      | | |      ____ 0\n    //         \\----  \\|/  ----/\n    //              \\--|--/\n    // -----------------------------------\n    //               --|--\n    //          ----/ /|\\ \\----\n    //     ____/      |||      \\____ 7\n    //   4           / | \\\n    //              |  |  |\n    //             /   |   \\\n    //            5    |    6\n\n    put.push([x + fars,  x + farl,  y + nearc, y + nearc]); // 0\n    put.push([x + fars,  x + farl,  y + farc , y + farc ]); // 7\n    put.push([x + nears, x + nearl, y + nearc, y + nearc]); // 3\n    put.push([x + nears, x + nearl, y + farc , y + farc ]); // 4\n\n    // The octants with x-crosses and y-stretchs\n    put.push([x + farc,  x + farc,  y + nears, y + nearl]); // 1\n    put.push([x + nearc, x + nearc, y + nears, y + nearl]); // 2\n    put.push([x + farc,  x + farc,  y + fars,  y + farl ]); // 6\n    put.push([x + nearc, x + nearc, y + fars,  y + farl ]); // 5\n  }\n  return put;\n}\n\nmodule.exports.renderPolygon = renderPolygon;\nmodule.exports.renderLine = renderLine;\nmodule.exports.renderCircle = renderCircle;\nmodule.exports.midpointCircleRasterize = midpointCircleRasterize;\nmodule.exports.sortByHSV = sortByHSV;\nmodule.exports.isHalfwayValue = isHalfwayValue;\nmodule.exports.flood = flood;\n\n\n//# sourceURL=webpack://raster/./src/algorithm.js?");

/***/ }),

/***/ "./src/attributes.js":
/*!***************************!*\
  !*** ./src/attributes.js ***!
  \***************************/
/***/ ((module) => {

eval("function Attributes(source, sizeInfo) {\n  this.source = source;\n  this.sizeInfo = sizeInfo;\n  return this;\n}\n\nAttributes.prototype.ensureConsistentTileset = function(tiles, palette) {\n  for (let j = 0; j < tiles.numTiles; j++) {\n    let tile = tiles.get(j);\n    let option = null;\n\n    // Get tile's color needs, pick a palette piece, then recolor\n    let colorNeeds = this._getColorNeeds(tile, palette);\n    let pieceNum = this._choosePalettePiece(colorNeeds, palette);\n    if (pieceNum === null) {\n      console.log(`[error] illegal tile, no palette: tileNum=${j}`);\n      continue;\n    }\n    this._recolorTile(pieceNum, palette, tile);\n  }\n}\n\nAttributes.prototype._getColorNeeds = function(tile, palette) {\n  let needSet = {};\n  for (let y = 0; y < tile.height; y++) {\n    for (let x = 0; x < tile.width; x++) {\n      // Look up the color index into colorSet\n      let k = tile.pitch*y + x;\n      let v = tile.data[k];\n      let c = palette.lookup(v);\n      needSet[c] = true;\n    }\n  }\n  let needs = Object.keys(needSet);\n  needs = needs.map(e => parseInt(e, 10));\n  needs.sort(function(a, b) {\n    return a - b;\n  });\n  return needs;\n}\n\nAttributes.prototype._choosePalettePiece = function(colorNeeds, palette) {\n  let candidates = [];\n\n  let optSize = this.sizeInfo.option_size;\n  // TODO: Handle non-even division\n  let numOpt = palette.length / optSize;\n\n  for (let n = 0; n < numOpt; n++) {\n    let collect = [];\n    for (let k = 0; k < optSize; k++) {\n      let j = n*optSize + k;\n      let pal = palette.get(j);\n      collect.push(pal.cval);\n    }\n\n    // Does set contain the colorNeeds\n    if (setContains(collect, colorNeeds)) {\n      candidates.push(n);\n    }\n  }\n\n  if (candidates.length >= 1) {\n    if (candidates.length > 1) {\n      // TODO: Do something more interesting here\n      console.log(`[warning] ambiguous palette choice: ${colorNeeds} => ${candidates}`);\n    }\n    return candidates[0];\n  }\n\n  return null;\n}\n\nAttributes.prototype._recolorTile = function(pieceNum, palette, tile) {\n  let optSize = this.sizeInfo.option_size;\n  // for each pixel\n  for (let y = 0; y < tile.height; y++) {\n    for (let x = 0; x < tile.width; x++) {\n      // Look up the color\n      let k = tile.pitch*y + x;\n      let c = tile.data[k];\n      // See what option this pixel is using\n      let choice = Math.floor(c / optSize);\n      if (choice != pieceNum) {\n        let badChoice = choice;\n        // Change to the correct color\n        // Must work because we got pieceNum\n        tile.data[k] = palette.relocateColorTo(c, pieceNum, optSize)\n      }\n    }\n  }\n}\n\nAttributes.prototype.realizeIndexedColor = function(c, x, y) {\n  let blockX = Math.floor(x / this.sizeInfo.block_width);\n  let blockY = Math.floor(y / this.sizeInfo.block_height);\n  let optSize = this.sizeInfo.option_size;\n  let k = blockY * this.source.pitch + blockX;\n  let choice = this.source.data[k];\n  return (c % optSize) + (choice * optSize);\n}\n\nfunction setContains(container, want) {\n  return want.every(function(e) { return container.indexOf(e) >= 0; });\n}\n\nmodule.exports.Attributes = Attributes;\n\n\n//# sourceURL=webpack://raster/./src/attributes.js?");

/***/ }),

/***/ "./src/color_set.js":
/*!**************************!*\
  !*** ./src/color_set.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const rgbMap = __webpack_require__(/*! ./rgb_map.js */ \"./src/rgb_map.js\");\nconst rgbColor = __webpack_require__(/*! ./rgb_color.js */ \"./src/rgb_color.js\");\n\nfunction Set(vals) {\n  if (!vals) {\n    vals = rgbMap.rgb_map_quick;\n  }\n  let [collect, lookup] = colorIntValsToRGBs(vals);\n  this.collect = collect;\n  this.lookup = lookup;\n  this.newIndex = this.collect.length;\n  return this;\n}\n\nfunction colorIntValsToRGBs(vals, allowDups) {\n  let collect = [];\n  let lookup = {};\n  for (let i = 0; i < vals.length; i++) {\n    if (typeof vals[i] != 'number') {\n      throw new Error(`type err: wanted number, got ${vals[i]}`);\n    }\n    let rgb = new rgbColor.RGBColor(vals[i]);\n    if (lookup[rgb] !== undefined && !allowDups) {\n      throw new Error(`duplicate color in set: ${rgb}`);\n    }\n    lookup[rgb] = collect.length;\n    collect.push(rgb);\n  }\n  return [collect, lookup];\n}\n\nSet.prototype.clear = function() {\n  this.assign(rgbMap.rgb_map_quick);\n}\n\nSet.prototype.size = function() {\n  return this.collect.length;\n}\n\nSet.prototype.get = function(i) {\n  return this.collect[i % this.collect.length];\n}\n\nSet.prototype.assign = function(vals, opts) {\n  opts = opts || {};\n  vals = vals.slice();\n  let [collect, lookup] = colorIntValsToRGBs(vals, opts.allowDups);\n  this.collect = collect;\n  this.lookup = lookup;\n  this.newIndex = this.collect.length;\n}\n\nSet.prototype.addEntry = function(rgb) {\n  if (typeof rgb == 'number') {\n    rgb = new rgbColor.RGBColor(rgb);\n  }\n  rgbColor.ensureIs(rgb);\n  // Find if it already exists\n  let i = this.lookup[rgb];\n  if (i !== undefined) {\n    return i;\n  }\n  // Add it to the map\n  i = this.newIndex % 0x100;\n  this.lookup[rgb] = this.collect.length;\n  this.collect[i] = rgb;\n  this.newIndex = (i + 1) % 0x100;\n  return i;\n}\n\nSet.prototype.find = function(rgb) {\n  if (typeof rgb != 'number') {\n    throw new Error('colorSet needs rgb as a number');\n  }\n  rgb = new rgbColor.RGBColor(rgb);\n  let i = this.lookup[rgb];\n  if (i !== undefined) {\n    return i;\n  }\n  return -1;\n}\n\nSet.prototype.use = function(rep) {\n  if (typeof rep == 'string') {\n    let text = rep;\n    if (text == 'quick') {\n      this.assign(rgbMap.rgb_map_quick);\n    } else if (text == 'dos') {\n      this.assign(rgbMap.rgb_map_dos);\n    } else if (text == 'nes') {\n      this.assign(rgbMap.rgb_map_nes, {allowDups: true});\n    } else if (text == 'gameboy') {\n      this.assign(rgbMap.rgb_map_gameboy);\n    } else if (text == 'pico8') {\n      this.assign(rgbMap.rgb_map_pico8);\n    } else if (text == 'zx-spectrum') {\n      this.assign(rgbMap.rgb_map_zx_spectrum, {allowDups: true});\n    } else if (text == 'c64') {\n      this.assign(rgbMap.rgb_map_c64);\n    } else if (text == 'grey') {\n      this.assign(rgbMap.rgb_map_grey);\n    } else {\n      throw new Error('Unknown color set: ' + text);\n    }\n  } else if (Array.isArray(rep)) {\n    let list = rep;\n    this.assign(list);\n  } else if (!rep) {\n    this.assign([]);\n  }\n  return this.collect.length;\n}\n\nSet.prototype.append = function(list) {\n  if (!Array.isArray(list)) {\n    throw new Error('can only append to colorSet using a list of rgb values');\n  }\n  for (let i = 0; i < list.length; i++) {\n    let v = list[i];\n    if (typeof v != 'number') {\n      throw new Error(`TODO: number err, got ${v}`);\n    }\n    let rgb = new rgbColor.RGBColor(v);\n    this.lookup[rgb] = this.collect.length;\n    this.collect.push(rgb);\n  }\n  // TODO: this.newIndex?\n  return this.collect.length;\n}\n\nmodule.exports.Set = Set;\n\n\n//# sourceURL=webpack://raster/./src/color_set.js?");

/***/ }),

/***/ "./src/compile.js":
/*!************************!*\
  !*** ./src/compile.js ***!
  \************************/
/***/ ((module) => {

eval("function createProgram(gl, vertex_shader_text, fragment_shader_text) {\n  var vertex_shader = loadShader(gl, vertex_shader_text, gl.VERTEX_SHADER);\n  var fragment_shader = loadShader(gl, fragment_shader_text, gl.FRAGMENT_SHADER);\n\n  const program = gl.createProgram();\n  gl.attachShader(program, vertex_shader);\n  gl.attachShader(program, fragment_shader);\n\n  gl.linkProgram(program);\n  // Check the link status\n  const outcome = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!outcome) {\n      const lastError = gl.getProgramInfoLog(program);\n      console.log('Error in program linking:' + lastError);\n      gl.deleteProgram(program);\n      return null;\n  }\n  return program;\n}\n\nfunction loadShader(gl, shaderSource, shaderType) {\n  // Create the shader object\n  const shader = gl.createShader(shaderType);\n  // Load the shader source\n  gl.shaderSource(shader, shaderSource);\n  // Compile the shader\n  gl.compileShader(shader);\n  // Check the compile status\n  const outcome = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!outcome) {\n    const lastError = gl.getShaderInfoLog(shader);\n    console.log('*** Error compiling shader \\'' + shader + '\\':' + lastError + `\\n` + shaderSource.split('\\n').map((l,i) => `${i + 1}: ${l}`).join('\\n'));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\n\n\nmodule.exports.createProgram = createProgram;\n\n\n//# sourceURL=webpack://raster/./src/compile.js?");

/***/ }),

/***/ "./src/destructure.js":
/*!****************************!*\
  !*** ./src/destructure.js ***!
  \****************************/
/***/ ((module) => {

eval("function DescribeSpec(choices) {\n  this.choices = choices;\n  return this;\n}\n\nfunction build(spec) {\n  let choices = [];\n  let mapping = {};\n  let needed = 0;\n  let row = [];\n  for (k = 0; k < spec.length; k++) {\n    let p = spec[k];\n    if (p == '||') {\n      choices.push({row: row, mapping: mapping, needed: needed});\n      row = [];\n      mapping = {};\n      needed = 0;\n      continue;\n    }\n    let param = toParam(p);\n    mapping[param.name] = row.length;\n    row.push(param);\n    if (param.req) {\n      needed++;\n    }\n  }\n  if (row.length > 0) {\n    choices.push({row: row, mapping: mapping, needed: needed});\n  }\n  return new DescribeSpec(choices);\n}\n\nfunction toParam(paramText) {\n  let pos = paramText.indexOf(':');\n  if (pos != -1) {\n    let [name, type] = paramText.split(':');\n    return {name: name, type: type, req: true};\n  }\n  pos = paramText.indexOf('?');\n  if (pos != -1) {\n    let [name, type] = paramText.split('?');\n    return {name: name, type: type, req: false};\n  }\n  throw new Error(`could not convert param ${paramText}`);\n}\n\nfunction from(fname, paramSpec, args, converter) {\n  let err = null;\n  let spec = build(paramSpec);\n  for (let i = 0; i < spec.choices.length; i++) {\n    let choice = spec.choices[i];\n    let match = tryMatch(choice, args);\n    if (match.values) {\n      if (i > 0 && converter) {\n        return converter(i, match.values);\n      }\n      return match.values;\n    }\n    if (err == null) {\n      err = match.err;\n    }\n  }\n  throw new Error(`function ${fname} ${err}`);\n}\n\nfunction tryMatch(choice, args) {\n  let row = choice.row;\n  let allowed = row.length;\n  let needed = choice.needed;\n  let mapping = choice.mapping;\n  if (args.length == 1 && isRawObject(args[0])) {\n    return tryMatchNamedParam(choice, args[0]);\n  }\n  return tryMatchPositionalParam(choice, args);\n}\n\nfunction tryMatchNamedParam(choice, argMap) {\n  let row = choice.row;\n  let allowed = row.length;\n  let needed = choice.needed;\n  let mapping = choice.mapping;\n\n  let haveArgKeys = Object.keys(argMap);\n  let values = [];\n  for (let i = 0; i < row.length; i++) {\n    let p = row[i];\n    let v = argMap[p.name];\n    if (v !== undefined) {\n      values.push(typeCoerce(v, p.type));\n      let pos = haveArgKeys.indexOf(p.name);\n      haveArgKeys.splice(pos, 1);\n    } else if (p.req) {\n      return {err: `missing parameter ${p.name}`};\n    }\n  }\n\n  // Validate there's no unknown parameters passed to the function.\n  if (haveArgKeys.length == 1) {\n    let f = haveArgKeys[0];\n    return {err: `unknown parameter ${f}`};\n  } else if (haveArgKeys.length > 1) {\n    return {err: `unknown parameters ${haveArgKeys}`};\n  }\n\n  return {values: values};\n}\n\nfunction tryMatchPositionalParam(choice, args) {\n  let row = choice.row;\n  let allowed = row.length;\n  let needed = choice.needed;\n  let mapping = choice.mapping;\n\n  if (args.length == 1 && needed == 1 && allowed == 2) {\n    // Short-cut to handle optional param[0]\n    if (!row[0].req) {\n      return {values: [null, args[0]]};\n    }\n  }\n\n  if (args.length < needed || args.length > allowed) {\n    return {err: `expected ${allowed} arguments, got ${args.length}`};\n  }\n\n  let values = [];\n  for (let i = 0; i < row.length; i++) {\n    let p = row[i];\n    if (i >= args.length) {\n      if (!p.req) {\n        continue;\n      }\n      return {err: `argument ${i} not found`};\n    }\n    values.push(typeCoerce(args[i], p.type));\n  }\n  return {values: values};\n}\n\nfunction isRawObject(thing) {\n  if (thing === null) {\n    return false;\n  }\n  if (typeof thing === 'object' && !Array.isArray(thing)) {\n    return (thing.constructor.name === 'Object');\n  }\n  return false;\n}\n\nfunction typeCoerce(value, type) {\n  if (type == 'i') {\n    // int\n    return value;\n  } else if (type == 'f') {\n    // float\n    return value;\n  } else if (type == 'ps') {\n    // points\n    return value;\n  } else if (type == 'a' || type == 'any') {\n    // points\n    return value;\n  } else if (type == 's') {\n    // string\n    return value;\n  } else if (type == 'b') {\n    // string\n    return value;\n  } else if (type == 'o') {\n    // object\n    return value;\n  } else {\n    throw new Error(`unknown type: ${type}`);\n  }\n}\n\nmodule.exports.from = from;\nmodule.exports.build = build;\n\n\n//# sourceURL=webpack://raster/./src/destructure.js?");

/***/ }),

/***/ "./src/display_2d_canvas.js":
/*!**********************************!*\
  !*** ./src/display_2d_canvas.js ***!
  \**********************************/
/***/ ((module) => {

eval("function Display() {\n  this.canvas = null;\n  this.numToLoad = 0;\n  this.numLoadDone = 0;\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  return this;\n}\n\nconst DONT_SHARPEN = 1;\n\nDisplay.prototype.initialize = function() {\n}\n\nDisplay.prototype.setSize = function(width, height) {\n  this.displayWidth = width;\n  this.displayHeight = height;\n}\n\nDisplay.prototype.setSource = function(renderer, zoomLevel) {\n  this.renderer = renderer;\n\n  var canvasElems = document.getElementsByTagName('canvas');\n  if (canvasElems.length >= 1) {\n    this.canvas = canvasElems[0];\n  } else {\n    var canvasContainer = document.getElementById('canvas');\n    if (canvasContainer) {\n      this.canvas = document.createElement('canvas');\n      canvasContainer.appendChild(this.canvas);\n    } else {\n      this.canvas = document.createElement('canvas');\n      document.body.appendChild(this.canvas);\n    }\n  }\n\n  // NOTE: zoomLevel is ignored\n  var elemWidth = this.displayWidth;\n  var elemHeight = this.displayHeight;\n\n  // Canvas's coordinate system.\n  this.canvas.width = elemWidth * DONT_SHARPEN;\n  this.canvas.height = elemHeight * DONT_SHARPEN;\n\n  // Size that element takes up in rendered page.\n  var style = document.createElement('style');\n  style.textContent = 'canvas { width: ' + elemWidth + 'px; height: ' +\n      elemHeight + 'px; border: solid 1px black;' +\n      'image-rendering: pixelated; image-rendering: crisp-edges;' +\n      '}';\n  document.body.appendChild(style);\n}\n\nDisplay.prototype.waitForImageLoads = function(cb) {\n  let self = this;\n  setTimeout(function() {\n    if (self.numToLoad > self.numLoadDone) {\n      self.waitForImageLoads(cb);\n      return;\n    }\n    cb();\n  }, 0);\n}\n\nDisplay.prototype.renderLoop = function(nextFrame, num, exitAfter, finalFunc) {\n  let frontBuffer = null;\n  let ctx = this.canvas.getContext('2d');\n  ctx.imageSmoothingEnabled = false;\n  ctx.mozImageSmoothingEnabled = false;\n  let self = this;\n\n  let renderIt = function() {\n    // Get the data buffer from the plane.\n    frontBuffer = self.renderer.render();\n\n    if (frontBuffer) {\n      let buff = Uint8ClampedArray.from(frontBuffer);\n      let image = new ImageData(buff, self.displayWidth, self.displayHeight);\n      ctx.putImageData(image, 0, 0);\n      if (num > 0) {\n        num--;\n      }\n    }\n\n    // Create the next frame.\n    nextFrame();\n\n    if (num == 0) {\n      if (finalFunc) {\n        finalFunc();\n      }\n      return;\n    }\n\n    // Wait for next frame.\n    requestAnimationFrame(renderIt);\n  };\n  this.waitForImageLoads(function() {\n    requestAnimationFrame(renderIt);\n  });\n}\n\nmodule.exports.Display = Display;\n\n\n\n//# sourceURL=webpack://raster/./src/display_2d_canvas.js?");

/***/ }),

/***/ "./src/display_ascii.js":
/*!******************************!*\
  !*** ./src/display_ascii.js ***!
  \******************************/
/***/ ((module) => {

eval("function DisplayAscii() {\n  this.renderer = null;\n  return this;\n}\n\nDisplayAscii.prototype.initialize = function() {\n}\n\nDisplayAscii.prototype.setSize = function(width, height) {\n  // pass\n}\n\nDisplayAscii.prototype.setSource = function(renderer, zoomLevel) {\n  this.renderer = renderer;\n}\n\nDisplayAscii.prototype.renderLoop = function(nextFrame) {\n  let plane = this.renderer.plane;\n  let buffer = plane.data;\n  let pitch = plane.pitch;\n  for (let y = 0; y < plane.height; y++) {\n    let line = '';\n    for (let x = 0; x < plane.width; x++) {\n      let k = y * plane.pitch + x;\n      line += byteToAscii(buffer[k]);\n    }\n    line += '\\n';\n    process.stdout.write(line);\n  }\n}\n\nlet alphabet = (\n  ' ._-=/|!^*%&' +\n  'abcdefghijklmnopqrstuvwxyz' +\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n\nfunction byteToAscii(b) {\n  return alphabet[b % 64];\n}\n\nmodule.exports.DisplayAscii = DisplayAscii;\n\n\n\n//# sourceURL=webpack://raster/./src/display_ascii.js?");

/***/ }),

/***/ "./src/display_webgl.js":
/*!******************************!*\
  !*** ./src/display_webgl.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compile = __webpack_require__(/*! ./compile.js */ \"./src/compile.js\");\n\nfunction Display() {\n  this.canvas = null;\n  return this;\n}\n\nDisplay.prototype.initialize = function() {\n  this.numToLoad = 0;\n  this.numLoadDone = 0;\n  this.imgAssets = [];\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n}\n\nconst SHARPEN = 2;\n\nDisplay.prototype.setSize = function(width, height) {\n  this.displayWidth = width;\n  this.displayHeight = height;\n}\n\nDisplay.prototype.setSource = function(renderer, zoomLevel) {\n  var canvasElems = document.getElementsByTagName('canvas');\n  if (canvasElems.length >= 1) {\n    this.canvas = canvasElems[0];\n  } else {\n    var canvasContainer = document.getElementById('canvas');\n    if (canvasContainer) {\n      this.canvas = document.createElement('canvas');\n      canvasContainer.appendChild(this.canvas);\n    } else {\n      this.canvas = document.createElement('canvas');\n      document.body.appendChild(this.canvas);\n    }\n  }\n\n  var gl = this.canvas.getContext(\"webgl\");\n  if (!gl) {\n    return;\n  }\n\n  this.renderer = renderer;\n  var plane = renderer.plane;\n  var elemWidth = this.displayWidth * zoomLevel;\n  var elemHeight = this.displayHeight * zoomLevel;\n\n  // Canvas's coordinate system.\n  this.canvas.width = elemWidth * SHARPEN;\n  this.canvas.height = elemHeight * SHARPEN;\n\n  // Size that element takes up in rendered page.\n  var style = document.createElement('style');\n  style.textContent = 'canvas { width: ' + elemWidth + 'px; height: ' +\n      elemHeight + 'px; border: solid 1px black;}';\n  document.body.appendChild(style);\n\n  var vertexShaderText = `\nattribute vec4 a_position;\nattribute vec2 a_texcoord;\nvarying vec2 v_texcoord;\nvoid main() {\n   gl_Position = a_position;\n   v_texcoord = a_texcoord;\n}\n`;\n\n  var fragmentShaderText = `\nprecision mediump float;\nvarying vec2 v_texcoord;\nuniform sampler2D u_texture;\nvoid main() {\n   gl_FragColor = texture2D(u_texture, v_texcoord);\n}\n`;\n\n  var program = compile.createProgram(gl, vertexShaderText, fragmentShaderText);\n\n  // look up where the vertex data needs to go.\n  var positionLocation = gl.getAttribLocation(program, \"a_position\");\n  var texcoordLocation = gl.getAttribLocation(program, \"a_texcoord\");\n\n  // lookup uniforms\n  var textureLocation = gl.getUniformLocation(program, \"u_texture\");\n\n  // Create a buffer.\n  var positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n  // Put a unit quad in the buffer\n  var positions = [\n   -1, 1,\n    1, 1,\n    1,-1,\n   -1, 1,\n    1,-1,\n   -1,-1,\n  ];\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n  // Create a buffer for texture coords\n  var texcoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\n  // Put texcoords in the buffer\n  var texcoords = [\n    0, 0,\n    1, 0,\n    1, 1,\n    0, 0,\n    1, 1,\n    0, 1,\n  ];\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n\n  // Hold onto the plane.\n  this.plane = plane;\n  this.gl = gl;\n\n  var texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,\n                this.displayWidth, this.displayHeight,\n                0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n  // let's assume all images are not a power of 2\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n  gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  // First update\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Tell WebGL to use our shader program pair\n  gl.useProgram(program);\n\n  // Setup the attributes to pull data from our buffers\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.enableVertexAttribArray(positionLocation);\n  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n  gl.enableVertexAttribArray(texcoordLocation);\n  gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n  // draw the quad (2 triangles, 6 vertices)\n  gl.drawArrays(gl.TRIANGLES, 0, 6);\n}\n\nDisplay.prototype.readImage = function(filepath) {\n  let imgElem = new Image;\n  let self = this;\n  // Start the image load, count how many are pending\n  this.numToLoad++;\n  imgElem.onload = function() {\n    self.numLoadDone++;\n  }\n  imgElem.src = \"/\" + filepath;\n  // Keep track of the image being loaded, to retrieve later\n  let id = this.imgAssets.length;\n  this.imgAssets.push({imgElem: imgElem, pixels: null});\n  return id;\n}\n\nDisplay.prototype.getImagePixels = function(id) {\n  let asset = this.imgAssets[id];\n  let imgElem = asset.imgElem;\n  if (asset.pixels == null) {\n    let canvas = document.createElement('canvas');\n    canvas.width = imgElem.width;\n    canvas.height = imgElem.height;\n    let ctx = canvas.getContext('2d');\n    ctx.drawImage(imgElem, 0, 0, imgElem.width, imgElem.height);\n    asset.pixels = ctx.getImageData(0, 0, imgElem.width, imgElem.height);\n  }\n  return asset.pixels;\n}\n\nDisplay.prototype.waitForImageLoads = function(cb) {\n  let self = this;\n  setTimeout(function() {\n    if (self.numToLoad > self.numLoadDone) {\n      self.waitForImageLoads(cb);\n      return;\n    }\n    cb();\n  }, 0);\n}\n\nDisplay.prototype.renderLoop = function(nextFrame, num, exitAfter, finalFunc) {\n  let pl = this.renderer.plane;\n  let gl = this.gl;\n  let frontBuffer = null;\n  let self = this;\n\n  // TODO: Use `num`\n\n  let renderIt = function() {\n    // Get the data buffer from the plane.\n    frontBuffer = self.renderer.render();\n\n    // Render to the display\n    if (frontBuffer) {\n      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0,\n                       self.displayWidth, self.displayHeight,\n                       gl.RGBA, gl.UNSIGNED_BYTE, frontBuffer);\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n      if (num > 0) {\n        num--;\n      }\n    }\n\n    // Create the next frame.\n    nextFrame();\n\n    if (num == 0) {\n      if (finalFunc) {\n        finalFunc();\n      }\n      return;\n    }\n\n    // Wait for next frame.\n    requestAnimationFrame(renderIt);\n  };\n  this.waitForImageLoads(function() {\n    requestAnimationFrame(renderIt);\n  });\n}\n\nmodule.exports.Display = Display;\n\n\n//# sourceURL=webpack://raster/./src/display_webgl.js?");

/***/ }),

/***/ "./src/drawing.js":
/*!************************!*\
  !*** ./src/drawing.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const algorithm = __webpack_require__(/*! ./algorithm.js */ \"./src/algorithm.js\");\nconst geometry = __webpack_require__(/*! ./geometry.js */ \"./src/geometry.js\");\nconst frameMemory = __webpack_require__(/*! ./frame_memory.js */ \"./src/frame_memory.js\");\n\nfunction Drawing() {\n  return this;\n}\n\nDrawing.prototype.getMethods = function() {\n  let result = [];\n  for (let fname in this) {\n    if (fname.endsWith('_params')) { continue; }\n    let pname = fname + '_params';\n    let cname = fname + '_convert';\n    if (this[pname]) {\n      result.push([fname, this[pname], this[cname], this[fname]]);\n    }\n  }\n  return result;\n}\n\nDrawing.prototype.setColor_params = ['color:i'];\nDrawing.prototype.setColor = function(color) {\n  this.frontColor = color;\n}\n\nDrawing.prototype.setTrueColor_params = ['rgb:i'];\nDrawing.prototype.setTrueColor = function(rgb) {\n  if (typeof rgb !== 'number') {\n    throw new Error(`setTrueColor needs rgb as a number, got ${rgb}`);\n  }\n  let color = this.scene.colorSet.addEntry(rgb);\n  this.setColor(color);\n}\n\nDrawing.prototype.fillColor_params = ['color:i'];\nDrawing.prototype.fillColor = function(color) {\n  this.bgColor = color;\n  this._needErase = true;\n}\n\nDrawing.prototype.fillBackground_params = ['color:i'];\nDrawing.prototype.fillBackground = function(color) {\n  this.bgColor = color;\n  this._needErase = true;\n}\n\nDrawing.prototype.fillTrueBackground_params = ['rgb:i'];\nDrawing.prototype.fillTrueBackground = function(rgb) {\n  let color = this.scene.colorSet.addEntry(rgb);\n  this.fillBackground(color);\n}\n\nDrawing.prototype.drawLine_params = ['x0:i', 'y0:i', 'x1:i', 'y1:i', 'cc?b'];\nDrawing.prototype.drawLine = function(x0, y0, x1, y1, cc) {\n  cc = cc ? 1 : 0;\n  let res = algorithm.renderLine(this, x0, y0, x1, y1, cc);\n  this.putSequence(res);\n}\n\nDrawing.prototype.drawDot_params = ['x:i', 'y:i'];\nDrawing.prototype.drawDot = function(x, y) {\n  let put = [[x, y]];\n  this.putSequence(put);\n}\n\nDrawing.prototype.fillDot_params = ['dots:any'];\nDrawing.prototype.fillDot = function(dots) {\n  return this.fillPattern(dots);\n}\n\nDrawing.prototype.fillPattern_params = ['dots:any'];\nDrawing.prototype.fillPattern = function(dots) {\n  this._prepare();\n  let buffer = this.data;\n\n  let height = dots.length;\n  let width = dots[0].length;\n  let mem = frameMemory.NewFrameMemory(this.offsetLeft, this.offsetTop, this.width, this.height);\n  for (let y = 0; y < mem.y_dim; y++) {\n    for (let x = 0; x < mem.x_dim; x++) {\n      let i = y % height;\n      let j = x % width;\n      mem[y*mem.pitch+x] = dots[i][j];\n    }\n  }\n  mem.copyTo(buffer, this);\n}\n\nDrawing.prototype.fillSquare_params = ['x:i', 'y:i', 'size:i'];\nDrawing.prototype.fillSquare = function(x, y, size) {\n  _renderRect(this, x, y, size, size, true);\n}\n\nDrawing.prototype.drawSquare_params = ['x:i', 'y:i', 'size:i'];\nDrawing.prototype.drawSquare = function(x, y, size) {\n  _renderRect(this, x, y, size, size, false);\n}\n\nDrawing.prototype.fillRect_params = ['x:i', 'y:i', 'w:i', 'h:i', '||',\n                                     'x:i', 'y:i', 'x1:i', 'y1:i'];\nDrawing.prototype.fillRect_convert = function(choice, vals) {\n  return [vals[0], vals[1], vals[2] - vals[0], vals[3] - vals[1]];\n}\nDrawing.prototype.fillRect = function(x, y, w, h) {\n  _renderRect(this, x, y, w, h, true);\n}\n\nDrawing.prototype.drawRect_params = ['x:i', 'y:i', 'w:i', 'h:i', '||',\n                                     'x:i', 'y:i', 'x1:i', 'y1:i'];\nDrawing.prototype.drawRect_convert = function(choice, vals) {\n  return [vals[0], vals[1], vals[2] - vals[0], vals[3] - vals[1]];\n}\nDrawing.prototype.drawRect = function(x, y, w, h) {\n  _renderRect(this, x, y, w, h, false);\n}\n\nfunction _renderRect(self, x, y, w, h, fill) {\n  x = Math.floor(x);\n  y = Math.floor(y);\n  let x1 = Math.floor(x + w - 1);\n  let y1 = Math.floor(y + h - 1);\n\n  let tmp;\n  if (x > x1) {\n    tmp = x;\n    x = x1;\n    x1 = tmp;\n  }\n  if (y > y1) {\n    tmp = y;\n    y = y1;\n    y1 = tmp;\n  }\n\n  let put = [];\n  if (fill) {\n    for (let n = y; n <= y1; n++) {\n      put.push([x, x + w - 1, n, n]);\n    }\n    self.putSequence(put);\n    return;\n  }\n\n  put.push([ x, x1,  y,  y]); // top\n  put.push([ x, x1, y1, y1]); // bottom\n  put.push([ x,  x,  y, y1]); // left\n  put.push([x1, x1,  y, y1]); // right\n  self.putSequence(put);\n}\n\nDrawing.prototype.fillCircle_params = ['x:i', 'y:i', 'r:i'];\nDrawing.prototype.fillCircle = function(x, y, r) {\n  let centerX = x + r;\n  let centerY = y + r;\n  let arc = algorithm.midpointCircleRasterize(r);\n  let half = algorithm.isHalfwayValue(r);\n  let put = algorithm.renderCircle(centerX, centerY, arc, null, true, half);\n  this.putSequence(put);\n}\n\nDrawing.prototype.drawCircle_params = ['x:i', 'y:i', 'r:i', 'width?i'];\nDrawing.prototype.drawCircle = function(x, y, r, width) {\n  let centerX = x + r;\n  let centerY = y + r;\n  let arc = algorithm.midpointCircleRasterize(r);\n  let inner = null;\n  if (width) {\n    inner = algorithm.midpointCircleRasterize(r - width + 1);\n  }\n  let half = algorithm.isHalfwayValue(r);\n  let put = algorithm.renderCircle(centerX, centerY, arc, inner, false, half);\n  this.putSequence(put);\n}\n\nDrawing.prototype.fillPolygon_params = ['points:ps', 'x?i', 'y?i'];\nDrawing.prototype.fillPolygon = function(polygon, x, y) {\n  x = x || 0;\n  y = y || 0;\n  let points = geometry.convertToPoints(polygon);\n  let res = algorithm.renderPolygon(this, x, y, points, true);\n  this.putSequence(res);\n}\n\nDrawing.prototype.drawPolygon_params = ['points:ps', 'x?i', 'y?i'];\nDrawing.prototype.drawPolygon = function(polygon, x, y) {\n  x = x || 0;\n  y = y || 0;\n  let points = geometry.convertToPoints(polygon);\n  let res = algorithm.renderPolygon(this, x, y, points, false);\n  this.putSequence(res);\n}\n\nDrawing.prototype.fillFlood_params = ['x:i', 'y:i'];\nDrawing.prototype.fillFlood = function(x, y) {\n  this._prepare();\n  let buffer = this.data;\n\n  let mem = frameMemory.NewFrameMemory(this.offsetLeft, this.offsetTop, this.width, this.height);\n  mem.from(buffer, this);\n  algorithm.flood(mem, x, y, this.frontColor);\n  mem.copyTo(buffer, this);\n}\n\nDrawing.prototype.fillFrame_params = ['options?o', 'fillerFunc:f'];\nDrawing.prototype.fillFrame = function(options, fillerFunc) {\n  if (this.mem == null) {\n    this.mem = frameMemory.NewFrameMemory(this.offsetLeft, this.offsetTop, this.width, this.height);\n  }\n  if (options && options.previous && !this.mem._didFrame) {\n    this.mem.createBackBuffer();\n    // If buffer is created from an unknown previous frame, load the contents\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        let k = y*this.width + x;\n        let j = y*this.pitch + x;\n        this.mem._backBuffer[k] = this.data[j];\n      }\n    }\n  }\n\n  this._prepare();\n  let buffer = this.data;\n  this.mem.from(buffer, this);\n\n  // Invoke the callback\n  if (fillerFunc.length == 1) {\n    fillerFunc(this.mem);\n  } else if (fillerFunc.length == 3) {\n    for (let y = 0; y < this.mem.y_dim; y++) {\n      for (let x = 0; x < this.mem.x_dim; x++) {\n        let ret = fillerFunc(this.mem, x, y);\n        if (ret !== null && ret !== undefined) {\n          this.mem[x + y*this.mem.pitch] = ret;\n        }\n      }\n    }\n  } else {\n    throw 'Invalid arguments for fillFrame: length = ' + fillerFunc.length;\n  }\n\n  this.mem.copyTo(buffer, this);\n  this.mem._didFrame = true;\n}\n\nDrawing.prototype.drawImage_params = ['img:a', 'x?i', 'y?i'];\nDrawing.prototype.drawImage = function(img, x, y) {\n  if (!img.data) {\n    throw 'drawImage: image has been opened, but not yet read';\n  }\n  x = x || 0;\n  y = y || 0;\n  if (this.width == 0 && this.height == 0) {\n    // TODO: Set the colorset as well.\n    this.setSize(img.width, img.height);\n  }\n  this.putImage(img, x, y);\n}\n\nDrawing.prototype.drawText_params = ['text:s', 'x:i', 'y:i'];\nDrawing.prototype.drawText = function(text, x, y) {\n  let font = this.scene.font;\n  if (!font) {\n    throw new Error('drawText: no font has been assigned');\n  }\n  if (!font.glyphs) {\n    throw new Error('drawText: font has been opened, but not yet read');\n  }\n\n  let put = [];\n  let cursor = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    let ch = text[i];\n    let num = ch.charCodeAt(0);\n    let name = num.toString(16);\n    let glyph = font.glyphs[name];\n\n    if (!glyph) {\n      console.log(`glyph for '${name}' not found`);\n      continue;\n    }\n\n    let len = 0;\n    for (let a = 0; a < glyph.length; a++) {\n      let row = glyph[a];\n      if (row.length > len) {\n        len = row.length;\n      }\n      for (let b = 0; b < row.length; b++) {\n        if (row[b] == '#') {\n          put.push([x + cursor + b, y + a]);\n        }\n      }\n    }\n    cursor += len;\n  }\n  this.putSequence(put);\n}\n\nmodule.exports.Drawing = Drawing;\n\n\n//# sourceURL=webpack://raster/./src/drawing.js?");

/***/ }),

/***/ "./src/font/tiny.js":
/*!**************************!*\
  !*** ./src/font/tiny.js ***!
  \**************************/
/***/ ((module) => {

eval("let tinyYaffContent = `\n0x30:\t###-\n\t#-#-\n\t#-#-\n\t#-#-\n\t###-\n\n0x31:\t-#--\n\t##--\n\t-#--\n\t-#--\n\t###-\n\n0x32:\t-##-\n\t#-#-\n\t--#-\n\t-#--\n\t###-\n\n0x33:\t##--\n\t--#-\n\t-##-\n\t--#-\n\t##--\n\n0x34:\t#-#-\n\t#-#-\n\t###-\n\t--#-\n\t--#-\n\n0x35:\t###-\n\t#---\n\t###-\n\t--#-\n\t###-\n\n0x36:\t###-\n\t#---\n\t###-\n\t#-#-\n\t###-\n\n0x37:\t###-\n\t--#-\n\t--#-\n\t--#-\n\t--#-\n\n0x38:\t###-\n\t#-#-\n\t###-\n\t#-#-\n\t###-\n\n0x39:\t###-\n\t#-#-\n\t###-\n\t--#-\n\t###-\n\n0x61:\t###-\n\t#-#-\n\t###-\n\t#-#-\n\t#-#-\n\n0x62:\t##--\n\t#-#-\n\t##--\n\t#-#-\n\t##--\n\n0x63:\t###-\n\t#---\n\t#---\n\t#---\n\t###-\n\n0x64:\t##--\n\t#-#-\n\t#-#-\n\t#-#-\n\t##--\n\n0x65:\t###-\n\t#---\n\t##--\n\t#---\n\t###-\n\n0x66:\t###-\n\t#---\n\t##--\n\t#---\n\t#---\n\n0x67:\t###-\n\t#---\n\t#-#-\n\t#-#-\n\t###-\n\n0x68:\t#-#-\n\t#-#-\n\t###-\n\t#-#-\n\t#-#-\n\n0x69:\t###-\n\t-#--\n\t-#--\n\t-#--\n\t###-\n\n0x6a:\t###-\n\t-#--\n\t-#--\n\t-#--\n\t##--\n\n0x6b:\t#-#-\n\t#-#-\n\t##--\n\t#-#-\n\t#-#-\n\n0x6c:\t#---\n\t#---\n\t#---\n\t#---\n\t###-\n\n0x6d:\t#-#-\n\t###-\n\t#-#-\n\t#-#-\n\t#-#-\n\n0x6e:\t#-#-\n\t###-\n\t###-\n\t###-\n\t#-#-\n\n0x6f:\t###-\n\t#-#-\n\t#-#-\n\t#-#-\n\t###-\n\n0x70:\t###-\n\t#-#-\n\t###-\n\t#---\n\t#---\n\n0x71:\t###-\n\t#-#-\n\t#-#-\n\t##--\n\t--#-\n\n0x72:\t###-\n\t#-#-\n\t##--\n\t#-#-\n\t#-#-\n\n0x73:\t###-\n\t#---\n\t###-\n\t--#-\n\t###-\n\n0x74:\t###-\n\t-#--\n\t-#--\n\t-#--\n\t-#--\n\n0x75:\t#-#-\n\t#-#-\n\t#-#-\n\t#-#-\n\t###-\n\n0x76:\t#-#-\n\t#-#-\n\t#-#-\n\t#-#-\n\t-#--\n\n0x77:\t#-#-\n\t#-#-\n\t#-#-\n\t###-\n\t#-#-\n\n0x78:\t#-#-\n\t#-#-\n\t-#--\n\t#-#-\n\t#-#-\n\n0x79:\t#-#-\n\t#-#-\n\t###-\n\t-#--\n\t-#--\n\n0x7a:\t###-\n\t--#-\n\t-#--\n\t#---\n\t###-\n\n`;\n\nmodule.exports.content = tinyYaffContent;\n\n\n//# sourceURL=webpack://raster/./src/font/tiny.js?");

/***/ }),

/***/ "./src/frame_memory.js":
/*!*****************************!*\
  !*** ./src/frame_memory.js ***!
  \*****************************/
/***/ ((module) => {

eval("function NewFrameMemory(left, top, w, h) {\n  var pitch = w;\n  var make = new Uint8Array(w * h);\n  make.left = left || 0;\n  make.top = top || 0;\n  make.y_dim = h;\n  make.x_dim = w;\n  make.height = h;\n  make.width = w;\n  make.pitch = pitch;\n  make._didFrame = false;\n  make._backBuffer = null;\n  make.put = function(x, y, v) {\n    if (x < 0 || x >= this.x_dim || y < 0 || y >= this.y_dim) {\n      return;\n    }\n    this[x + y*this.pitch] = v;\n  };\n  make.get = function(x, y) {\n    if (x < 0 || x >= this.x_dim || y < 0 || y >= this.y_dim) {\n      return 0;\n    }\n    return this[x + y*this.pitch];\n  };\n  make.getPrevious = function(x, y) {\n    let k = x + y*this.pitch;\n    if (this._backBuffer) {\n      return this._backBuffer[x + y*this.pitch];\n    }\n    throw 'getPrevious only works if fillFrame is given {previous:true}';\n  };\n  make.createBackBuffer = function() {\n    var self = this;\n    if (self._backBuffer == null) {\n      self._backBuffer = new Uint8Array(w * h);\n    }\n    self._backBuffer.set(self);\n  }\n  make.copyTo = function(buffer, info) {\n    let offs = this.top*info.pitch + this.left;\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        let k = y*this.pitch + x;\n        let j = y*info.pitch + x + offs;\n        buffer[j] = this[k];\n      }\n    }\n  }\n  make.from = function(buffer, info) {\n    let offs = this.top*info.pitch + this.left;\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        let k = y*this.pitch + x;\n        let j = y*info.pitch + x + offs;\n        this[k] = buffer[j];\n      }\n    }\n  }\n  return make;\n}\n\nmodule.exports.NewFrameMemory = NewFrameMemory;\n\n\n//# sourceURL=webpack://raster/./src/frame_memory.js?");

/***/ }),

/***/ "./src/geometry.js":
/*!*************************!*\
  !*** ./src/geometry.js ***!
  \*************************/
/***/ ((module) => {

eval("function convertToPolygon(pointsOrPolygon) {\n  // If already a polygon, just return it.\n  if (pointsOrPolygon instanceof Polygon) {\n    return pointsOrPolygon;\n  }\n  // If a list of points, figure out if it is pixel-positioned.\n  let points = pointsOrPolygon;\n  var isPixelPolygon = true;\n  for (let i = 0; i < points.length; i++) {\n    if (!isInt(points[i][0]) && !isInt(points[i][0])) {\n      isPixelPolygon = false;\n      break;\n    }\n  }\n  // If pixel-positioned, convert to float-positioned.\n  if (isPixelPolygon) {\n    for (let i = 0; i < points.length; i++) {\n      points[i][0] += 0.50000001;\n      points[i][1] += 0.50000001;\n    }\n  }\n  return new Polygon(points)\n}\n\nfunction convertToPoints(pointsOrPolygon) {\n  if (pointsOrPolygon instanceof Polygon) {\n    return pointsOrPolygon.points();\n  }\n  return pointsOrPolygon;\n}\n\nfunction Polygon(points, centerAxis) {\n  this._points = points;\n  centerAxis = centerAxis || guessCenterOf(this._points);\n  this._centerX = centerAxis[0];\n  this._centerY = centerAxis[1];\n  return this;\n}\n\nPolygon.prototype.points = function() {\n  return this._points;\n}\n\nPolygon.prototype.center = function() {\n  return [this._centerX, this._centerY];\n}\n\nPolygon.prototype.rotate = function(angle) {\n  let result = [];\n  for (var i = 0; i < this._points.length; i++) {\n    var x = this._points[i][0];\n    var y = this._points[i][1];\n    // Translate to the origin.\n    x = x - this._centerX;\n    y = y - this._centerY;\n    // Rotate the points around the origin.\n    var rot_x = x * Math.cos(angle) - y * Math.sin(angle);\n    var rot_y = x * Math.sin(angle) + y * Math.cos(angle);\n    // Translate back to the original grid system, and add.\n    result.push([rot_x + this._centerX, rot_y + this._centerY]);\n  }\n  this._points = result;\n}\n\nfunction guessCenterOf(points) {\n  var left  = points[0][0];\n  var top   = points[0][1];\n  var right = points[0][0];\n  var bot   = points[0][1];\n  for (var i = 1; i < points.length; i++) {\n    var p = points[i];\n    if (p[0] < left) {\n      left = p[0];\n    }\n    if (p[0] > right) {\n      right = p[0];\n    }\n    if (p[1] < top) {\n      top = p[1];\n    }\n    if (p[1] > bot) {\n      bot = p[1];\n    }\n  }\n  return [(left+right)/2, (top+bot)/2];\n}\n\nfunction isInt(n) {\n  let fract = n - Math.floor(n);\n  return fract == 0.0;\n}\n\nmodule.exports.Polygon = Polygon;\nmodule.exports.convertToPolygon = convertToPolygon;\nmodule.exports.convertToPoints = convertToPoints;\nmodule.exports.isInt = isInt;\n\n\n//# sourceURL=webpack://raster/./src/geometry.js?");

/***/ }),

/***/ "./src/image_loader.js":
/*!*****************************!*\
  !*** ./src/image_loader.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const rgbColor = __webpack_require__(/*! ./rgb_color.js */ \"./src/rgb_color.js\");\nconst algorithm = __webpack_require__(/*! ./algorithm.js */ \"./src/algorithm.js\");\nconst palette = __webpack_require__(/*! ./palette.js */ \"./src/palette.js\");\n\nfunction Loader(resources, scene) {\n  this.list = [];\n  this.resources = resources;\n  this.scene = scene;\n  return this;\n}\n\nLoader.prototype.loadImage = function(filename, opt) {\n  let sortUsingHSV = false;\n  if (opt.sortColors) {\n    if (opt.sortColors == 'usingHSV') {\n      sortUsingHSV = true;\n    } else {\n      throw new Error(`unknown sortColors key \"${opt.sortColors}\"`);\n    }\n  } else if (Object.keys(opt) > 0) {\n    throw new Error(`unknown option value ${opt}`);\n  }\n\n  let img = new ImagePlane();\n  img.parentLoader = this;\n  img.filename = filename;\n  img.id = this.list.length;\n  img.left = 0;\n  img.top = 0;\n  // resources.openImage assigns these:\n  img.elemNode = null;\n  img.width = 0;\n  img.height = 0;\n  img.pitch = 0;\n  img.data = null;\n  img.colorSet = this.scene.colorSet;\n  img.palette = this.scene.palette;\n  img.sortUsingHSV = sortUsingHSV;\n\n  let ret = this.resources.openImage(filename, img);\n  if (ret == -1) {\n    throw new Error('image not found');\n  }\n  // HACK: openImage should return a uint8array, not ArrayBuffer\n  // web_env returns a Uint8Array (but also img.data == null currently)\n  // node_env returns an ArrayBuffer\n  if (img.rgbBuff) {\n    if (img.rgbBuff.constructor.name == 'ArrayBuffer') {\n      img.rgbBuff = new Uint8Array(img.rgbBuff);\n    } else {\n      throw 'ERROR!';\n    }\n    img.fillData();\n  }\n  this.list.push(img);\n  return img;\n}\n\nLoader.prototype.resolveAll = function(cb) {\n  let self = this;\n  function waitForImageLoad() {\n    if (self.resources.allLoaded()) {\n      return cb();\n    }\n    setTimeout(waitForImageLoad, 0);\n  }\n  // Changing this to be async breaks node_env. Since the node_env has a\n  // blocking render loop, this call needs to be synchronous as well.\n  waitForImageLoad();\n}\n\nfunction ImagePlane() {\n  this.parentLoader = null;\n  this.filename = null;\n  this.id = null;\n  this.slice = null;\n  this.width = 0;\n  this.height = 0;\n  this.data = null;\n  this.alpha = null;\n  this.rgbBuff = null;\n  this.colorSet = null;\n  this.palette = null;\n  this.sortUsingHSV = false;\n  return this;\n}\n\nImagePlane.prototype.copy = function(x, y, w, h) {\n  let make = new ImagePlane();\n  make.parentLoader = this.parentLoader;\n  make.filename = this.filename;\n  make.id = this.id;\n  make.left = x;\n  make.top = y;\n  make.width = w;\n  make.height = h;\n  make.pitch = this.pitch;\n  make.data = this.data;\n  make.alpha = this.alpha;\n  make.rgbBuff = this.rgbBuff;\n  make.colorSet = this.colorSet;\n  make.palette = this.palette;\n  this.sortUsingHSV = this.sortUsingHSV;\n  return make;\n}\n\nImagePlane.prototype.get = function(x, y) {\n  let k = y*this.pitch + x;\n  return this.data[k];\n}\n\nImagePlane.prototype.fillData = function() {\n  if (this.data == null) {\n    let numPixels = this.height * this.width;\n    this.data = new Uint8Array(numPixels);\n    this.alpha = new Uint8Array(numPixels);\n  }\n  let needs = this._collectColorNeeds();\n\n  // Sort the colors, if required.\n  if (this.sortUsingHSV) {\n    needs.rgbItems = algorithm.sortByHSV(needs.rgbItems);\n  }\n\n  // Create mapping from rgb to 8-bit value\n  let remap = {};\n  for (let i = 0; i < needs.rgbItems.length; i++) {\n    let rgbval = needs.rgbItems[i].toInt();\n    if (this.palette) {\n      let cval = this.colorSet.find(rgbval);\n      if (cval == -1) {\n        c = this.palette.insertWhereAvail(rgbval);\n        if (c == null) {\n          throw new Error(`palette exists, and image ${this.filename} uses a color not found in the colorset: ${needs.rgbItems[i]}`);\n        }\n      } else {\n        c = this.palette.find(cval);\n        if (c == null) {\n          throw new Error(`image uses valid colors, but palette is full. color=0x${rgbval.toString(16)}`);\n        }\n      }\n    } else {\n      c = this.colorSet.addEntry(rgbval);\n    }\n    remap[rgbval] = c;\n  }\n\n  // Build the data buffer\n  for (let y = 0; y < this.height; y++) {\n    for (let x = 0; x < this.width; x++) {\n      let k = y * this.pitch + x;\n      this.alpha[k] = this.rgbBuff[k*4+3];\n      if (this.alpha[k] < 0x80) {\n        continue;\n      }\n      let r = this.rgbBuff[k*4+0];\n      let g = this.rgbBuff[k*4+1];\n      let b = this.rgbBuff[k*4+2];\n      let rgbval = r * 0x10000 + g * 0x100 + b;\n      let c = remap[rgbval];\n      this.data[k] = c;\n    }\n  }\n}\n\nImagePlane.prototype._collectColorNeeds = function() {\n  let lookup = {};\n  let rgbItems = [];\n  for (let y = 0; y < this.height; y++) {\n    for (let x = 0; x < this.width; x++) {\n      let k = y * this.pitch + x;\n      this.alpha[k] = this.rgbBuff[k*4+3];\n      // Transparent pixels are not added to the colorSet.\n      if (this.alpha[k] < 0x80) {\n        continue;\n      }\n      let r = this.rgbBuff[k*4+0];\n      let g = this.rgbBuff[k*4+1];\n      let b = this.rgbBuff[k*4+2];\n      let rgbval = r * 0x10000 + g * 0x100 + b;\n      if (lookup[rgbval] !== undefined) {\n        continue;\n      }\n      // New rgb color found, add it\n      lookup[rgbval] = rgbItems.length;\n      rgbItems.push(new rgbColor.RGBColor(rgbval));\n    }\n  }\n  return {lookup: lookup, rgbItems: rgbItems};\n}\n\nImagePlane.prototype.then = function(cb) {\n  this.parentLoader.resolveAll(cb);\n}\n\nmodule.exports.Loader = Loader;\n\n\n//# sourceURL=webpack://raster/./src/image_loader.js?");

/***/ }),

/***/ "./src/lib.js":
/*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const rgbColor = __webpack_require__(/*! ./rgb_color.js */ \"./src/rgb_color.js\");\nconst scene = __webpack_require__(/*! ./scene.js */ \"./src/scene.js\");\nconst drawing = __webpack_require__(/*! ./drawing.js */ \"./src/drawing.js\");\nconst destructure = __webpack_require__(/*! ./destructure.js */ \"./src/destructure.js\");\nconst plane = __webpack_require__(/*! ./plane.js */ \"./src/plane.js\");\nconst tiles = __webpack_require__(/*! ./tiles.js */ \"./src/tiles.js\");\n\nfunction Raster(env) {\n  this.scene = new scene.Scene(env);\n  this._addMethods();\n  return this;\n}\n\nRaster.prototype._addMethods = function() {\n  let self = this;\n  let d = new drawing.Drawing();\n  let methods = d.getMethods();\n  for (let i = 0; i < methods.length; i++) {\n    let [fname, params, converter, impl] = methods[i];\n    this[fname] = function() {\n      let args = Array.from(arguments);\n      self.scene[fname].apply(self.scene, args);\n    }\n  }\n}\n\nRaster.prototype._removeMethods = function() {\n  let self = this;\n  let d = new drawing.Drawing();\n  let methods = d.getMethods();\n  for (let i = 0; i < methods.length; i++) {\n    let [fname, params, converter, impl] = methods[i];\n    delete this[fname];\n  }\n}\nRaster.prototype.resetState = function() {\n  this.scene.resetState();\n  this.time = 0.0;\n  this.timeClick = 0;\n  this._addMethods();\n}\n\nRaster.prototype.TAU = 6.283185307179586;\nRaster.prototype.time = 0.0;\nRaster.prototype.timeClick = 0;\n\n////////////////////////////////////////\n// Setup the draw target\n\nRaster.prototype.setZoom = function(zoomLevel) {\n  this.scene.setZoom(zoomLevel);\n}\n\nRaster.prototype.setTitle = function(text) {\n  this.scene.setTitle(text);\n}\n\nRaster.prototype.originAtCenter = function() {\n  this.scene.originAtCenter();\n}\n\nRaster.prototype.useColors = function(rep) {\n  return this.scene.useColors(rep);\n}\n\nRaster.prototype.appendColors = function(rep) {\n  return this.scene.appendColors(rep);\n}\n\nRaster.prototype.numColors = function() {\n  return this.scene.numColors();\n}\n\nRaster.prototype.useDisplay = function(disp) {\n  this.scene.useDisplay(disp);\n}\n\nRaster.prototype.Plane = function() {\n  if (new.target === undefined) {\n    throw new Error('Plane constructor must be called with `new`');\n  }\n  let p = new plane.Plane();\n  p._addMethods(true);\n  return p;\n}\n\nRaster.prototype.Tileset = function() {\n  if (new.target === undefined) {\n    throw new Error('Tileset constructor must be called with `new`');\n  }\n  let args = arguments;\n  // TODO: destructure?\n  return new tiles.Tileset(args[0], args[1]);\n}\n\n////////////////////////////////////////\n// Methods with interesting return values\n\nRaster.prototype.loadImage = function(filepath, opt) {\n  return this.scene.makeShape('load', [filepath, opt]);\n}\n\nRaster.prototype.makePolygon = function(shape, angle) {\n  return this.scene.makeShape('polygon', [shape]);\n}\n\nRaster.prototype.rotatePolygon = function(shape, angle) {\n  return this.scene.makeShape('rotate', [shape, angle]);\n}\n\nRaster.prototype.oscil = function(period, fracOffset, click) {\n  period = period || 60;\n  if (fracOffset === undefined) {\n    fracOffset = 0.0;\n  }\n  if (click === undefined) {\n    click = this.timeClick;\n  }\n  click = click + Math.round(period * fracOffset);\n  return (1.0 - Math.cos(click * this.TAU / period)) / 2.0000001;\n}\n\nRaster.prototype.getPaletteEntry = function(x, y) {\n  return this.scene.getPaletteEntry(x, y);\n}\n\nRaster.prototype.getPaletteAll = function(opt) {\n  opt = opt || {};\n  return this.scene.getPaletteAll(opt);\n}\n\nRaster.prototype.usePalette = function(vals) {\n  return this.scene.usePalette(vals);\n}\n\nRaster.prototype.setFont = function(spec) {\n  this.scene.setFont(spec);\n}\n\nRaster.prototype.setTileset = function(which) {\n  this.scene.setTileset(which);\n}\n\nRaster.prototype.mixColors = function(spec) {\n  let result = [];\n  let cursor = 0;\n  let leftColor = spec[cursor + 1];\n  let rightColor = spec[cursor + 3];\n  let startIndex = spec[0];\n  let targetIndex = spec[2];\n  let endIndex = spec[spec.length - 2];\n  for (let i = 0; i < endIndex; i++) {\n    if (i == targetIndex) {\n      cursor += 2;\n      startIndex = targetIndex;\n      leftColor = spec[cursor + 1];\n      rightColor = spec[cursor + 3];\n      targetIndex = spec[cursor + 2];\n    }\n    let L = new rgbColor.RGBColor(leftColor);\n    let R = new rgbColor.RGBColor(rightColor);\n    let rgb = L.interpolate(R, i, {min: startIndex, max: targetIndex});\n    result.push(rgb.toInt());\n  }\n  return result;\n}\n\nRaster.prototype.clonePlane = function() {\n  let s = this.scene.aPlane;\n  let p = s.clone();\n  p.pitch = p.width;\n  let numPixels = p.height * p.pitch;\n  let newBuff = new Uint8Array(numPixels);\n  for (let y = 0; y < p.height; y++) {\n    for (let x = 0; x < p.width; x++) {\n      let k = y*s.pitch + x;\n      let j = y*p.pitch + x;\n      newBuff[j] = s.data[k];\n    }\n  }\n  p.data = newBuff;\n  return p;\n}\n\nRaster.prototype.select = function(opt) {\n  let spec = ['x:i', 'y:i', 'w:i', 'h:i'];\n  [x, y, w, h] = destructure.from('select', spec, arguments, null);\n  return this.scene.select(x, y, w, h);\n}\n\nRaster.prototype.setSize = function(width, height) {\n  let spec = ['w:i', 'h?i'];\n  [width, height] = destructure.from('setSize', spec, arguments, null);\n  if (height === undefined) { height = width; }\n  this.scene.setSize(width, height);\n}\n\nRaster.prototype.setScrollX = function(v) {\n  this.scene.setScrollX(v);\n}\n\nRaster.prototype.setScrollY = function(v) {\n  this.scene.setScrollY(v);\n}\n\n////////////////////////////////////////\n\nRaster.prototype.useTileset = function(pl, sizeInfo) {\n  this.scene.useTileset(pl, sizeInfo);\n}\n\nRaster.prototype.useAttributes = function(pl, sizeInfo) {\n  this.scene.useAttributes(pl, sizeInfo);\n}\n\nRaster.prototype.usePlane = function(pl) {\n  this.scene.aPlane = pl;\n  this._removeMethods();\n  this.scene._removeMethods();\n  this.scene._config.usingNonPrimaryPlane = true;\n}\n\nRaster.prototype.useInterrupts = function(conf) {\n  this.scene.useInterrupts(conf);\n}\n\n////////////////////////////////////////\n// Display endpoints\n\nRaster.prototype.run = function(drawFunc) {\n  var self = this;\n  var runner = this.scene;\n  runner.then(function() {\n    runner.run(\n      drawFunc,\n      self.nextFrame.bind(self),\n    );\n  });\n}\n\nRaster.prototype.show = function(drawFunc, finalFunc) {\n  var runner = this.scene;\n  runner.then(function() {\n    if (drawFunc) {\n      drawFunc();\n    }\n    runner.show(finalFunc);\n  });\n}\n\nRaster.prototype.save = function(savepath) {\n  var runner = this.scene\n  runner.then(function() {\n    runner.save(savepath);\n  });\n}\n\nRaster.prototype.showFrame = function() {\n  var runner = this.scene;\n  var args = arguments;\n  runner.then(function() {\n    runner.fillFrame.apply(runner, args);\n    runner.show();\n  });\n}\n\nRaster.prototype.quit = function() {\n  var runner = this.scene;\n  runner.then(function() {\n    runner.quit();\n  });\n}\n\nRaster.prototype.nextFrame = function() {\n  var runner = this.scene;\n  var self = this;\n  runner.then(function() {\n    self.timeClick++;\n    self.time = self.timeClick / 60.0;\n    runner.nextFrame();\n  });\n}\n\nRaster.prototype.on = function(eventName, callback) {\n  this.scene.handleEvent(eventName, callback);\n}\n\n////////////////////////////////////////\n// Export\n\nvar env = null;\nif (typeof window === 'undefined') {\n  // Node.js\n  if (false) {}\n} else if (true) {\n  // Web browser\n  env = __webpack_require__(/*! ./web_env.js */ \"./src/web_env.js\");\n}\n\nvar singleton = new Raster(env);\nif (typeof window === 'undefined') {\n  // Node.js\n  module.exports = singleton;\n} else {\n  // Web browser\n  window['require'] = function(moduleName) {\n    if (moduleName === 'raster') {\n      return singleton;\n    }\n    throw 'Could not require module named \"' + moduleName + '\"';\n  };\n}\n\n\n//# sourceURL=webpack://raster/./src/lib.js?");

/***/ }),

/***/ "./src/palette.js":
/*!************************!*\
  !*** ./src/palette.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const rgbColor = __webpack_require__(/*! ./rgb_color.js */ \"./src/rgb_color.js\");\nconst colorSet = __webpack_require__(/*! ./color_set.js */ \"./src/color_set.js\");\nconst plane = __webpack_require__(/*! ./plane.js */ \"./src/plane.js\");\nconst palette = __webpack_require__(/*! ./palette.js */ \"./src/palette.js\");\nconst renderer = __webpack_require__(/*! ./renderer.js */ \"./src/renderer.js\");\nconst textLoader = __webpack_require__(/*! ./text_loader.js */ \"./src/text_loader.js\");\n\nfunction PaletteCollection(items, saveService) {\n  if (saveService != null && !saveService.saveTo) {\n    throw new Error('PaletteCollection given invalid saveService');\n  }\n  this.items = items;\n  for (let i = 0; i < items.length; i++) {\n    if (items[i].constructor != palette.PaletteEntry) {\n      throw new Error('PaletteCollection got invalid item[${i}], should be PaletteEntry');\n    }\n  }\n  // length\n  this.length = this.items.length;\n  // items are directly indexable\n  for (let i = 0; i < this.items.length; i++) {\n    this[i] = this.items[i];\n  }\n  this.saveService = saveService;\n  // Customize how console.log displays this object.\n  this[Symbol.for('nodejs.util.inspect.custom')] = this._stringify;\n  return this;\n}\n\nPaletteCollection.prototype.get = function(c) {\n  return this.items[c];\n}\n\nPaletteCollection.prototype.reset = function() {\n  for (let i = 0; i < this.items.length; i++) {\n    let it = this.items[i];\n    it.cval = it.idx;\n    it.rgb = new rgbColor.RGBColor(it.colors.get(it.cval));\n  }\n}\n\nPaletteCollection.prototype.save = function(filename) {\n  let target = new plane.Plane();\n  // Preserve\n  let preserveScene = target.scene;\n  // Save operation\n  target.scene = null;\n  this._saveTo(target, filename);\n  // Restore\n  target.scene = preserveScene;\n}\n\nPaletteCollection.prototype._saveTo = function(target, savepath) {\n  let numX = 8;\n  let numY = Math.ceil(this.items.length / 8);\n  // Parameterize\n  let showWidth = 7;\n  let showHeight = 5;\n  let showPad = 4;\n  let showBetween = 2;\n  let showOuter = 3;\n  // Calculate\n  let offsetLeft = showOuter;\n  let offsetTop = showOuter;\n  let gridX = showWidth + showPad * 2 + showBetween;\n  let gridY = showHeight + showPad * 2 + showBetween;\n  // Draw the palette\n  target.setSize(numX * gridX - showBetween + showOuter * 2,\n                 numY * gridY - showBetween + showOuter * 2);\n\n  // Create dependencies for drawing\n  let loader = new textLoader.TextLoader(this.saveService);\n  let font = loader.createFontResource('tiny');\n  let colors = new colorSet.Set([]);\n  colors.assign([]);\n  target.scene = {\n    _config: {\n      width: target.width,\n      height: target.height,\n    },\n    colorSet: colors,\n    font: font,\n  };\n\n  // Draw the palette format\n  target.fillTrueBackground(0x606060);\n  for (let k = 0; k < this.items.length; k++) {\n    let rgbInt = this.items[k].rgb.toInt();\n    let j = k % 8;\n    let i = Math.floor(k / 8);\n    let y = i * gridY;\n    let x = j * gridX;\n    target.setTrueColor(rgbInt);\n    target.fillRect(x + showOuter, y + showOuter,\n                    gridX - showBetween, gridY - showBetween);\n    let v = k.toString();\n    if (v.length < 2) {\n      v = '0' + v;\n    }\n    if (this._isLightColor(this.items[k].rgb)) {\n      target.setTrueColor(0);\n    } else {\n      target.setTrueColor(0xffffff);\n    }\n    target.drawText(`${v}`, x + showPad + showOuter, y + showPad + showOuter);\n  }\n\n  // Render it and save\n  let rend = new renderer.Renderer(colorSet);\n  rend.plane = target;\n  rend.configure(target.scene);\n  let [width, height] = rend.size();\n  let buff = rend.render();\n  let pitch = target.width*4;\n  if (buff.pitch) {\n    pitch = buff.pitch;\n  }\n  this.saveService.saveTo(savepath, buff, width, height, pitch);\n}\n\nPaletteCollection.prototype._isLightColor = function(rgb) {\n  let total = rgb.r + rgb.g + rgb.b;\n  let avg = total / 3;\n  return avg > 0x80;\n}\n\nPaletteCollection.prototype.toString = function() {\n  return this._stringify(0, {});\n}\n\nPaletteCollection.prototype._stringify = function(depth, opts) {\n  let elems = [];\n  for (let i = 0; i < this.items.length; i++) {\n    let it = this.items[i];\n    elems.push(`${i}:[${it.cval}]=${it.hex()}`);\n  }\n  return 'PaletteCollection{' + elems.join(', ') + '}';\n}\n\nPaletteCollection.prototype.find = function(cval) {\n  for (let n = 0; n < this.items.length; n++) {\n    let ent = this.items[n];\n    if (cval === ent.cval) {\n      return n;\n    }\n  }\n  return null;\n}\n\nPaletteCollection.prototype.lookup = function(v) {\n  return this.items[v].cval;\n}\n\nPaletteCollection.prototype.insertWhereAvail = function(rgbval) {\n  for (let n = 0; n < this.items.length; n++) {\n    let ent = this.items[n];\n    if (ent.isAvail) {\n      ent.cval = 0;\n      ent.isAvail = false;\n      ent.drop = rgbval;\n      return n;\n    }\n  }\n  return null;\n}\n\nPaletteCollection.prototype.relocateColorTo = function(c, pieceNum, optSize) {\n  let cval = this.items[c].cval;\n  for (let n = 0; n < this.items.length; n++) {\n    if (c == n) { continue; }\n    if (this.items[n].cval == cval) {\n      return n;\n    }\n  }\n  return null;\n}\n\nfunction PaletteEntry(rgb, idx, colors) {\n  if (rgb.constructor != rgbColor.RGBColor) {\n    throw new Error(`PaletteEntry: rgb must be a RGBColor`);\n  }\n  if (typeof idx != 'number') {\n    throw new Error(`PaletteEntry: idx must be a number`);\n  }\n  if (colors.constructor != colorSet.Set) {\n    throw new Error(`PaletteEntry: colors must be a color.Set`);\n  }\n  this.rgb = rgb;\n  this.idx = idx;\n  this.cval = idx;\n  this.colors = colors;\n  this.isAvail = false;\n  return this;\n}\n\nPaletteEntry.prototype.setColor = function(n) {\n  this.cval = n;\n  this.rgb = new rgbColor.RGBColor(this.colors.get(this.cval));\n}\n\nPaletteEntry.prototype.hex = function() {\n  let text = this.rgb.toInt().toString(16);\n  if (this.drop) {\n    text = this.drop.toString(16);\n  }\n  while (text.length < 6) {\n    text = '0' + text;\n  }\n  if (this.drop) {\n    return '(0x' + text + ')';\n  }\n  return '0x' + text;\n}\n\nPaletteEntry.prototype.dump = function() {\n  let ans = '';\n  ans += 'PaletteEntry{';\n  ans += JSON.stringify(this.rgb);\n  ans += ` idx=${this.idx}`;\n  ans += ` cval=${this.cval}`;\n  ans += ` }`;\n  return ans;\n}\n\nmodule.exports.PaletteCollection = PaletteCollection;\nmodule.exports.PaletteEntry = PaletteEntry;\n\n\n//# sourceURL=webpack://raster/./src/palette.js?");

/***/ }),

/***/ "./src/plane.js":
/*!**********************!*\
  !*** ./src/plane.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const drawing = __webpack_require__(/*! ./drawing.js */ \"./src/drawing.js\");\nconst destructure = __webpack_require__(/*! ./destructure.js */ \"./src/destructure.js\");\n\nvar _g_scene = null;\n\nfunction Plane() {\n  this.clear();\n  this.scene = _g_scene;\n  return this;\n}\n\nfunction setGlobalScene(scene) {\n  _g_scene = scene;\n}\n\nPlane.prototype.clear = function() {\n  this.width = 0;\n  this.height = 0;\n  this.pitch = 0;\n  this.data = null;\n  this.mem = null;\n  this.rgbBuffer = null;\n  this._backBuffer = null;\n  this.bgColor = 0;\n  this.frontColor = 7;\n  this._addMethods();\n}\n\nPlane.prototype.clone = function() {\n  this._prepare();\n  let make = new Plane();\n  make.width = this.width;\n  make.height = this.height;\n  make.pitch = this.pitch;\n  make.data = this.data;\n  make.mem = this.mem;\n  make.bgColor = this.bgColor;\n  make.frontColor = this.frontColor;\n  // rgbBuffer\n  // _backBuffer\n  // bgColor\n  // frontColor\n  return make;\n}\n\nPlane.prototype._addMethods = function(shouldDestruct) {\n  let self = this;\n  let d = new drawing.Drawing();\n  let methods = d.getMethods();\n  for (let i = 0; i < methods.length; i++) {\n    let [fname, paramSpec, converter, impl] = methods[i];\n    this[fname] = function() {\n      let args = Array.from(arguments);\n      if (paramSpec === undefined) {\n        throw new Error(`function ${fname} does not have parameter spec`);\n      }\n      let realArgs = args;\n      if (shouldDestruct) {\n        realArgs = destructure.from(fname, paramSpec, args, converter);\n      }\n      impl.bind(self).apply(self.aPlane, realArgs);\n    }\n  }\n}\n\nPlane.prototype.setSize = function(w, h) {\n  // TODO: use destructure.from\n  if (h === undefined) {\n    h = w;\n  }\n  this.width = w;\n  this.height = h;\n  // TODO: Make this adjustment be semi-random instead\n  this.pitch = w + 2;\n}\n\nPlane.prototype.nextFrame = function() {\n  if (this.mem) {\n    this.mem._didFrame = false;\n  }\n}\n\nPlane.prototype._prepare = function() {\n  if (this.data && !this._needErase) {\n    return;\n  }\n  if (this.width == 0 || this.height == 0) {\n    this.setSize(100, 100);\n  }\n  let numPixels = this.height * this.pitch;\n  if (!this.data) {\n    this.data = new Uint8Array(numPixels);\n    this._needErase = true;\n  }\n  let c = this.bgColor;\n  for (let k = 0; k < numPixels; k++) {\n    this.data[k] = c;\n  }\n  this._needErase = false;\n}\n\nPlane.prototype.get = function(x, y) {\n  this._prepare();\n  this._offs = this.offsetTop * this.pitch + this.offsetLeft || 0;\n  let k = y * this.pitch + x;\n  return this.data[this._offs + k];\n}\n\nPlane.prototype.put = function(x, y, v) {\n  this._prepare();\n  this._offs = this.offsetTop * this.pitch + this.offsetLeft || 0;\n  let k = y * this.pitch + x;\n  // TODO: Check width and height\n  this.data[this._offs + k] = v;\n}\n\nPlane.prototype.putSequence = function(seq) {\n  this._prepare();\n  this._offs = this.offsetTop * this.pitch + this.offsetLeft || 0;\n  // Get the current color\n  let c = this.frontColor;\n  // Each sequence\n  for (let i = 0; i < seq.length; i++) {\n    let elem = seq[i];\n    if (elem.length == 2) {\n      // Sequence of length 2 is a single point\n      let x = Math.floor(elem[0]);\n      let y = Math.floor(elem[1]);\n      let k = y * this.pitch + x;\n      // TODO: Add offsets\n      this.data[this._offs + k] = c;\n    } else if (elem.length == 4) {\n      // Sequnce of length 4 is a range\n      let x0 = Math.floor(elem[0]);\n      let x1 = Math.floor(elem[1]);\n      let y0 = Math.floor(elem[2]);\n      let y1 = Math.floor(elem[3]);\n      // Swap endpoints if needed\n      if (x0 > x1) {\n        let tmp = x0;\n        x0 = x1;\n        x1 = tmp;\n      }\n      if (y0 > y1) {\n        let tmp = y0;\n        y0 = y1;\n        y1 = tmp;\n      }\n      // Range only goes straight horizontal or straight vertical\n      if (x0 == x1) {\n        if (x0 < 0 || x1 >= this.width) {\n          continue;\n        }\n        if (y0 < 0) {\n          y0 = 0;\n        }\n        if (y1 >= this.height) {\n          y1 = this.height - 1;\n        }\n        let x = x0;\n        for (let y = y0; y <= y1; y++) {\n          let k = y * this.pitch + x;\n          // TODO: Add offsets\n          this.data[this._offs + k] = c;\n        }\n      } else if (y0 == y1) {\n        if (y0 < 0 || y1 >= this.height) {\n          continue;\n        }\n        if (x0 < 0) {\n          x0 = 0;\n        }\n        if (x1 >= this.width) {\n          x1 = this.width - 1;\n        }\n        let y = y0;\n        for (let x = x0; x <= x1; x++) {\n          let k = y * this.pitch + x;\n          // TODO: Add offsets\n          this.data[this._offs + k] = c;\n        }\n      }\n    }\n  }\n}\n\nPlane.prototype.putImage = function(img, baseX, baseY) {\n  this._prepare();\n  let imageTop = img.top;\n  let imageLeft = img.left;\n  let imageHeight = img.height;\n  let imageWidth = img.width;\n  let imagePitch = img.pitch;\n  let imageData = img.data;\n  let imageAlpha = img.alpha;\n  if (this.data == null) {\n    return;\n  }\n  baseX = Math.floor(baseX);\n  baseY = Math.floor(baseY);\n  for (let y = imageTop; y < imageHeight; y++) {\n    for (let x = imageLeft; x < imageWidth; x++) {\n      let j = y*imagePitch + x;\n      let putX = x + baseX;\n      let putY = y + baseY;\n      if (putX < 0 || putX >= this.width ||\n          putY < 0 || putY >= this.height) {\n        continue;\n      }\n      let k = putY*this.pitch + putX;\n      if (imageAlpha && imageAlpha[j] >= 0x80) {\n        // TODO: this._offs\n        this.data[k] = imageData[j];\n      }\n    }\n  }\n}\n\nmodule.exports.Plane = Plane;\nmodule.exports.setGlobalScene = setGlobalScene;\n\n\n//# sourceURL=webpack://raster/./src/plane.js?");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const rgbColor = __webpack_require__(/*! ./rgb_color.js */ \"./src/rgb_color.js\");\n\nfunction Renderer() {\n  this.rgbBuffer = null;\n  this.plane = null;\n  this.tiles = null;\n  this.colorSet = null;\n  this.palette = null;\n  this.attrs = null;\n  this.interrupts = null;\n  this.config = null;\n  return this;\n}\n\nRenderer.prototype.clear = function() {\n  this.rgbBuffer = null;\n  this.tiles = null;\n  this.colorSet = null;\n  this.palette = null;\n  this.attrs = null;\n  this.interrupts = null;\n  this.config = null;\n}\n\nRenderer.prototype.configure = function(owner) {\n  this.tiles = owner.tiles;\n  this.colorSet = owner.colorSet;\n  this.palette = owner.palette;\n  this.attrs = owner.attrs;\n  this.interrupts = owner.interrupts;\n  this.config = owner._config;\n}\n\nRenderer.prototype.size = function () {\n  let width = this.config.width;\n  let height = this.config.height;\n  if (!width) {\n    if (this.tiles) {\n      width = this.plane.width * this.tiles.tileWidth;\n    } else {\n      width = this.plane.width;\n    }\n  }\n  if (!height) {\n    if (this.tiles) {\n      height = this.plane.height * this.tiles.tileHeight;\n    } else {\n      height = this.plane.height;\n    }\n  }\n  return [width, height];\n}\n\nRenderer.prototype.render = function() {\n  // Calculate size of the buffer to render.\n  let width = this.config.width;\n  let height = this.config.height;\n  if (!width || !height) {\n    if (!this.tiles) {\n      width = this.plane.width;\n      height = this.plane.height;\n    } else {\n      width = this.plane.width * this.tiles.tileWidth;\n      height = this.plane.height * this.tiles.tileHeight;\n    }\n  }\n\n  // Allocate the buffer.\n  if (this.rgbBuffer == null) {\n    let numPoints = width * height;\n    this.rgbBuffer = new Uint8Array(numPoints*4);\n    this.rgbBuffer.pitch = width*4;\n  }\n  if (!this.plane.data) {\n    return this.rgbBuffer;\n  }\n\n  // If no interrupts, render everything at once.\n  if (!this.interrupts) {\n    return this._renderRegion(0, 0, width, height);\n  }\n\n  // Otherwise, render between each interrupt.\n  let renderPoint = 0;\n  for (let k = 0; k < this.interrupts.length + 1; k++) {\n    let scanLine;\n    if (k < this.interrupts.length) {\n      scanLine = this.interrupts[k].scanline;\n    } else {\n      scanLine = height;\n    }\n    this._renderRegion(0, renderPoint, width, scanLine);\n    renderPoint = scanLine;\n    if (k < this.interrupts.length) {\n      this.interrupts[k].irq();\n    }\n  }\n\n  return this.rgbBuffer;\n}\n\nRenderer.prototype._renderRegion = function(left, top, right, bottom) {\n  let source = this.plane.data;\n  let sourcePitch = this.plane.pitch;\n  let sourceWidth = this.plane.width;\n  let sourceHeight = this.plane.height;\n\n  if (this.tiles != null) {\n    // Assert that useTileset requires usePlane\n    if (!this.config.usingNonPrimaryPlane) {\n      throw new Error('cannot use tileset without also using plane');\n    }\n    // Calculate the size\n    let tileSize = this.tiles.tileWidth * this.tiles.tileHeight;\n    let numPoints = this.plane.height * this.plane.width;\n    sourceWidth = this.plane.width * this.tiles.tileWidth;\n    sourceHeight = this.plane.height * this.tiles.tileHeight;\n    sourcePitch = this.tiles.tileWidth * this.plane.width;\n    source = new Uint8Array(numPoints * tileSize);\n\n    for (let yTile = 0; yTile < this.plane.height; yTile++) {\n      for (let xTile = 0; xTile < this.plane.width; xTile++) {\n        let k = yTile*this.plane.pitch + xTile;\n        let c = this.plane.data[k];\n        let t = this.tiles.get(c);\n        if (t === undefined) {\n          throw new Error(`invalid tile number ${c} at ${xTile},${yTile}`);\n        }\n        for (let i = 0; i < t.height; i++) {\n          for (let j = 0; j < t.width; j++) {\n            let y = yTile * this.tiles.tileHeight + i;\n            let x = xTile * this.tiles.tileWidth + j;\n            let n = y * sourceWidth + x;\n            source[n] = t.get(j, i);\n          }\n        }\n      }\n    }\n  }\n\n  let targetPitch = this.rgbBuffer.pitch;\n\n  let scrollY = Math.floor(this.config.scrollY || 0);\n  let scrollX = Math.floor(this.config.scrollX || 0);\n  scrollY = ((scrollY % sourceHeight) + sourceHeight) % sourceHeight;\n  scrollX = ((scrollX % sourceWidth) + sourceWidth) % sourceWidth;\n\n  for (let placement = 0; placement < 4; placement++) {\n    let regL, regR, regU, regD;\n    if ((placement == 0) || (placement == 2)) {\n      // left half\n      regL = scrollX;\n      regR = Math.min(sourceWidth, right + scrollX);\n    } else {\n      // right half\n      regL = 0;\n      regR = scrollX - sourceWidth + right;\n    }\n\n    if ((placement == 0) || (placement == 1)) {\n      // top half\n      regU = Math.max(scrollY, top + scrollY);\n      regD = Math.min(sourceHeight, bottom + scrollY);\n    } else {\n      // bottom half\n      regU = Math.max(scrollY - sourceHeight + top, 0);\n      regD = scrollY - sourceHeight + bottom;\n    }\n\n    for (let y = regU; y < regD; y++) {\n      for (let x = regL; x < regR; x++) {\n        let i, j;\n        if (placement == 0) {\n          i = y - scrollY;\n          j = x - scrollX;\n        } else if (placement == 1) {\n          i = y - scrollY;\n          j = x - scrollX + sourceWidth;\n        } else if (placement == 2) {\n          i = y - scrollY + sourceHeight;\n          j = x - scrollX;\n        } else if (placement == 3) {\n          i = y - scrollY + sourceHeight;\n          j = x - scrollX + sourceWidth;\n        } else {\n          continue;\n        }\n        if (i < top || i >= bottom || j < left || j >= right) {\n          // TODO: should never happen\n          continue;\n        }\n        let s = y*sourcePitch + x;\n        let t = i*targetPitch + j*4;\n        let rgb;\n        if (this.attrs) {\n          let c = this.attrs.realizeIndexedColor(source[s], x, y);\n          rgb = this._toColor(c);\n        } else {\n          rgb = this._toColor(source[s]);\n        }\n        this.rgbBuffer[t+0] = rgb.r;\n        this.rgbBuffer[t+1] = rgb.g;\n        this.rgbBuffer[t+2] = rgb.b;\n        this.rgbBuffer[t+3] = 0xff;\n      }\n    }\n  }\n\n  return this.rgbBuffer;\n}\n\nRenderer.prototype._toColor = function(c) {\n  let rgb;\n  if (this.palette) {\n    let ent = this.palette.get(c);\n    if (!ent) {\n      rgb = rgbColor.BLACK;\n    } else {\n      rgb = ent.rgb;\n    }\n  } else {\n    rgb = this.colorSet.get(c);\n  }\n  rgbColor.ensureIs(rgb);\n  return rgb\n}\n\nmodule.exports.Renderer = Renderer;\n\n\n//# sourceURL=webpack://raster/./src/renderer.js?");

/***/ }),

/***/ "./src/resources.js":
/*!**************************!*\
  !*** ./src/resources.js ***!
  \**************************/
/***/ ((module) => {

eval("function Resources() {\n  this.numToLoad = 0;\n  this.numLoadDone = 0;\n  return this;\n}\n\nResources.prototype.openImage = function(filename, imgPlane) {\n  let self = this;\n  // The html node for loading the Image.\n  let imgElem = new Image;\n  imgPlane.elemNode = imgElem;\n\n  // Wait for the image to load\n  this.numToLoad++;\n  imgElem.onload = function() {\n    // Get the pixel data and save it on the resource.\n    let canvas = document.createElement('canvas');\n    canvas.width = imgElem.width;\n    canvas.height = imgElem.height;\n    let ctx = canvas.getContext('2d');\n    ctx.drawImage(imgElem, 0, 0, imgElem.width, imgElem.height);\n    let pixels = ctx.getImageData(0, 0, imgElem.width, imgElem.height);\n    imgPlane.rgbBuff = pixels.data;\n    imgPlane.width = pixels.width;\n    imgPlane.pitch = pixels.width;\n    imgPlane.height = pixels.height;\n    // TODO: Process the pixel data so it matches the colorSet\n    // Mark the load as completed.\n    self.numLoadDone++;\n    //\n    imgPlane.fillData();\n  }\n  // TODO: Handle 404 not found for images\n  imgElem.src = '/' + filename;\n}\n\nResources.prototype.openText = function(filename) {\n  let self = this;\n  let file = {src: filename};\n  self.numToLoad++;\n  fetch(filename).then(function(res) {\n    res.text().then(function(text) {\n      file.handleFileRead(text);\n      self.numLoadDone++;\n    });\n  });\n  return file;\n}\n\nResources.prototype.localAsset = function(relpath) {\n  throw new Error('cannot get local assets');\n}\n\nResources.prototype.allLoaded = function() {\n  return this.numLoadDone == this.numToLoad;\n}\n\nResources.prototype.saveTo = function() {\n  throw new Error('cannot save image');\n}\n\nmodule.exports.Resources = Resources;\n\n\n//# sourceURL=webpack://raster/./src/resources.js?");

/***/ }),

/***/ "./src/rgb_color.js":
/*!**************************!*\
  !*** ./src/rgb_color.js ***!
  \**************************/
/***/ ((module) => {

eval("function RGBColor(val) {\n  if (val === undefined || val === null) {\n    this.r = this.g = this.b = 0;\n    return this;\n  }\n\n  // if int, treat it as 24-bit rgb value\n  if (typeof val == 'number') {\n    this.r = Math.floor(val / 0x10000) % 0x100;\n    this.g = Math.floor(val / 0x100)   % 0x100;\n    this.b = Math.floor(val / 0x1)     % 0x100;\n    return this;\n  }\n\n  // if string, treat it as a html style hex value\n  if (typeof val == 'string') {\n    if (val[0] == '#') {\n      this.r = parseInt(val.slice(1, 3), 16)\n      this.g = parseInt(val.slice(3, 5), 16)\n      this.b = parseInt(val.slice(5, 7), 16)\n      return this;\n    }\n    throw `could not convert to RGB: ${val}`\n  }\n\n  // if list, treat it as a 3 tuple\n  if (val.constructor.name == 'Array') {\n    if (val.length == 3) {\n      this.r = val[0];\n      this.g = val[1];\n      this.b = val[2];\n      return this;\n    }\n    throw `could not convert to RGB: ${val}`\n  }\n\n  // if object, treat as a r,g,b struct\n  if (val.constructor.name == 'Object') {\n    this.r = val.r;\n    this.g = val.g;\n    this.b = val.b;\n    return this;\n  }\n\n  if (val.constructor == RGBColor) {\n    this.r = val.r;\n    this.g = val.g;\n    this.b = val.b;\n    return this;\n  }\n\n  throw `could not convert to RGB: ${val}`\n}\n\nRGBColor.prototype.copy = function() {\n  let res = new RGBColor();\n  res.r = this.r;\n  res.g = this.g;\n  res.b = this.b;\n  return res;\n}\n\nRGBColor.prototype.equals = function(other) {\n  if (other.constructor !== RGBColor) {\n    throw new Error('RGBColor.equals can only compare to RGBColor');\n  }\n  return (this.r == other.r && this.g == other.g && this.b == other.b);\n}\n\nRGBColor.prototype.interpolate = function(other, val, inp) {\n  if (inp === undefined || inp.min === undefined || !inp.max) {\n    throw 'interpolate needs range like {min: min, max: max}';\n  }\n  let min = inp.min;\n  let max = inp.max;\n\n  if (max < min) {\n    return new RGBColor();\n  }\n  if (val <= min) {\n    return this.copy();\n  }\n  if (val >= max) {\n    return other.copy();\n  }\n\n  let res = new RGBColor();\n\n  let range = max - min;\n  let dist = val - min;\n\n  let weightRite = dist / range;\n  let weightLeft = 1.0 - (dist / range);\n\n  res.r = Math.round(this.r * weightLeft + other.r * weightRite);\n  res.g = Math.round(this.g * weightLeft + other.g * weightRite);\n  res.b = Math.round(this.b * weightLeft + other.b * weightRite);\n\n  return res;\n}\n\nRGBColor.prototype.toInt = function() {\n  return this.r * 0x10000 + this.g * 0x100 + this.b;\n}\n\nRGBColor.prototype.toHexStr = function() {\n  let rtxt = this.r.toString(16);\n  let gtxt = this.g.toString(16);\n  let btxt = this.b.toString(16);\n  while (rtxt.length < 2) {\n    rtxt = '0' + rtxt;\n  }\n  while (gtxt.length < 2) {\n    gtxt = '0' + gtxt;\n  }\n  while (btxt.length < 2) {\n    btxt = '0' + btxt;\n  }\n  return `#${rtxt}${gtxt}${btxt}`;\n}\n\nRGBColor.prototype.toString = function() {\n  return 'RGBColor{' + this.toHexStr() + '}';\n}\n\nfunction ensureIs(rgb) {\n  if (rgb == null) {\n    throw new Error(`rgb value invalid, is null`);\n  }\n  if (rgb.constructor !== RGBColor) {\n    throw new Error(`rgb value invalid, is ${rgb}`);\n  }\n}\n\nvar BLACK = new RGBColor();\n\nmodule.exports.RGBColor = RGBColor;\nmodule.exports.BLACK = BLACK;\nmodule.exports.ensureIs = ensureIs;\n\n\n//# sourceURL=webpack://raster/./src/rgb_color.js?");

/***/ }),

/***/ "./src/rgb_map.js":
/*!************************!*\
  !*** ./src/rgb_map.js ***!
  \************************/
/***/ ((module) => {

eval("const rgb_map_quick = [\n  0x000000,0x202020,0x404040,0x606060,0x808080,0xa0a0a0,0xc0c0c0,0xffffff,\n  0x331414,0x332414,0x303314,0x1c3314,0x143325,0x142833,0x1e1433,0x33142a,\n  0x661919,0x664019,0x5e6619,0x2b6619,0x196642,0x194a66,0x301966,0x66194f,\n  0xbf2626,0xbf7326,0xb0bf26,0x4abf26,0x26bf78,0x2687bf,0x5426bf,0xbf2691,\n  0xff3333,0xff9933,0xebff33,0x63ff33,0x33ffa0,0x33b4ff,0x7033ff,0xff33c2,\n  0xff7373,0xffb973,0xf1ff73,0x93ff73,0x73ffbe,0x73ccff,0x9d73ff,0xff73d5,\n  0xffa6a6,0xffd2a6,0xf6ffa6,0xbbffa6,0xa6ffd5,0xa6deff,0xc1a6ff,0xffa6e4,\n  0xffd9d9,0xffecd9,0xfbffd9,0xe2ffd9,0xd9ffed,0xd9f1ff,0xe4d9ff,0xffd9f4,\n];\n\nconst rgb_map_dos = [\n  0x000000, // 0 block\n  0x0000aa, // 1 blue\n  0x00aa00, // 2 green\n  0x00aaaa, // 3 cyan\n  0xaa0000, // 4 red\n  0xaa00aa, // 5 purple\n  0xaa5500, // 6 brown\n  0xaaaaaa, // 7 grey\n  0x555555, // 8 light grey\n  0x5555ff, // 9 light blue\n  0x55ff55, // a light green\n  0x55ffff, // b light cyan\n  0xff5555, // c light red\n  0xff55ff, // d light purple\n  0xffff55, // e light yellow\n  0xffffff, // f white\n];\n\nconst rgb_map_nes = [\n//-------------------------------------------------------------------------\n//  grey 00  blue 01  blue 02 purple03 purple04   red 05   red 06   red 07\n   0x7c7c7c,0x0000fc,0x0000bc,0x4428bc,0x940084,0xa80020,0xa81000,0x881400,\n// brown 08 green 09 green 0a green 0b  cyan 0c black 0d black 0e black 0f\n   0x503000,0x007800,0x006800,0x005800,0x004058,0x080808,0x080808,0x000000,\n//-------------------------------------------------------------------------\n//  grey 10  blue 11  blue 12 purple13 purple14   red 15   red 16 orange17\n   0xbcbcbc,0x0078f8,0x0058f8,0x6844fc,0xd800cc,0xe40058,0xf83800,0xe45c10,\n// brown 18 green 19 green 1a green 1b  cyan 1c  grey 1d black 1e black 1f\n   0xac7c00,0x00b800,0x00a800,0x00a844,0x008888,0x080808,0x080808,0x080808,\n//-------------------------------------------------------------------------\n// white 20  blue 21  blue 22 purple23  pink 24  pink 25 orange26 orange27\n   0xf8f8f8,0x3cbcfc,0x6888fc,0x9878f8,0xf878f8,0xf85898,0xf87858,0xfca044,\n// orange28 green 29 green 2a green 2b  cyan 2c  grey 2d black 2e black 2f\n   0xf8b800,0xb8f818,0x58d854,0x58f898,0x00e8d8,0x787878,0x080808,0x080808,\n//-------------------------------------------------------------------------\n// white 30  blue 31  blue 32 purple33  pink 34  pink 35 peach 36 peach 37\n   0xfcfcfc,0xa4e4fc,0xb8b8f8,0xd8b8f8,0xf8b8f8,0xf8a4c0,0xf0d0b0,0xfce0a8,\n// peach 38 yellow39 green 3a green 3b  cyan 3c  grey 3d black 3e black 3f\n   0xf8d878,0xd8f878,0xb8f8b8,0xb8f8d8,0x00fcfc,0xf8d8f8,0x080808,0x080808\n];\n\nconst rgb_map_gameboy = [\n  0x003f00,\n  0x2e7320,\n  0x8cbf0a,\n  0xa0cf0a,\n];\n\nconst rgb_map_pico8 = [\n  0x000000,\n  0x1d2b53,\n  0x7e2553,\n  0x008751,\n  0xab5236,\n  0x5f574f,\n  0xc2c3c7,\n  0xfff1e8,\n  0xff004d,\n  0xffa300,\n  0xffec27,\n  0x00e436,\n  0x29adff,\n  0x83769c,\n  0xff77a8,\n  0xffccaa,\n];\n\nconst rgb_map_zx_spectrum = [\n  0x000000,\n  0x0000d7, // basic blue\n  0xd70000, // basic red\n  0xd700d7, // basic magenta\n  0x00d700, // basic green\n  0x00d7d7, // basic cyan\n  0xd7d700, // basic yellow\n  0xd7d7d7, // basic white\n  0x000000,\n  0x0000ff, // bright blue\n  0xff0000, // bright red\n  0xff00ff, // bright magenta\n  0x00ff00, // bright green\n  0x00ffff, // bright cyan\n  0xffff00, // bright yellow\n  0xffffff, // bright white\n];\n\nconst rgb_map_c64 = [\n  0x000000,\n  0xffffff,\n  0x880000,\n  0xaaffee,\n  0xcc44cc,\n  0x00cc55,\n  0x0000aa,\n  0xeeee77,\n  0xdd8855,\n  0x664400,\n  0xff7777,\n  0x333333,\n  0x777777,\n  0xaaff66,\n  0x0088ff,\n  0xbbbbbb,\n];\n\nconst rgb_map_grey = function() {\n  let colors = [];\n  for (let k = 0; k < 0x100; k++) {\n    let c = k * 0x10000 + k * 0x100 + k;\n    colors.push(c);\n  }\n  return colors;\n}();\n\nmodule.exports.rgb_map_quick   = rgb_map_quick;\nmodule.exports.rgb_map_nes     = rgb_map_nes;\nmodule.exports.rgb_map_dos     = rgb_map_dos;\nmodule.exports.rgb_map_grey    = rgb_map_grey;\nmodule.exports.rgb_map_gameboy = rgb_map_gameboy;\nmodule.exports.rgb_map_pico8   = rgb_map_pico8;\nmodule.exports.rgb_map_zx_spectrum = rgb_map_zx_spectrum;\nmodule.exports.rgb_map_c64     = rgb_map_c64;\n\n\n//# sourceURL=webpack://raster/./src/rgb_map.js?");

/***/ }),

/***/ "./src/scene.js":
/*!**********************!*\
  !*** ./src/scene.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const colorSet = __webpack_require__(/*! ./color_set.js */ \"./src/color_set.js\");\nconst drawing = __webpack_require__(/*! ./drawing.js */ \"./src/drawing.js\");\nconst destructure = __webpack_require__(/*! ./destructure.js */ \"./src/destructure.js\");\nconst algorithm = __webpack_require__(/*! ./algorithm.js */ \"./src/algorithm.js\");\nconst palette = __webpack_require__(/*! ./palette.js */ \"./src/palette.js\");\nconst renderer = __webpack_require__(/*! ./renderer.js */ \"./src/renderer.js\");\nconst geometry = __webpack_require__(/*! ./geometry.js */ \"./src/geometry.js\");\nconst imageLoader = __webpack_require__(/*! ./image_loader.js */ \"./src/image_loader.js\");\nconst textLoader = __webpack_require__(/*! ./text_loader.js */ \"./src/text_loader.js\");\nconst displayAscii = __webpack_require__(/*! ./display_ascii.js */ \"./src/display_ascii.js\");\nconst plane = __webpack_require__(/*! ./plane.js */ \"./src/plane.js\");\nconst scene = __webpack_require__(/*! ./scene.js */ \"./src/scene.js\");\nconst tiles = __webpack_require__(/*! ./tiles.js */ \"./src/tiles.js\");\nconst attributes = __webpack_require__(/*! ./attributes.js */ \"./src/attributes.js\");\nconst rgbColor = __webpack_require__(/*! ./rgb_color.js */ \"./src/rgb_color.js\");\n\n////////////////////////////////////////\n\nconst FRAMES_LOOP_FOREVER = -1;\n\nfunction Scene(env) {\n  this._addMethods();\n  this.env = env;\n  this.resources = env.makeResources();\n  this.display = env.makeDisplay();\n  this.saveService = this.resources;\n\n  this.colorSet = new colorSet.Set();\n  this.renderer = new renderer.Renderer(this.colorSet);\n\n  this.font = null;\n  this.palette = null;\n  this.tiles = null;\n  this.attrs = null;\n  this.interrupts = null;\n\n  plane.setGlobalScene(this);\n  this.aPlane = new plane.Plane();\n\n  this._config = {};\n  this.numFrames = FRAMES_LOOP_FOREVER;\n  this.initialize();\n  return this;\n}\n\nScene.prototype.initialize = function () {\n  this._config.zoomScale = 1;\n  this._config.titleText = '';\n  this.colorSet.clear();\n  this.imgLoader = new imageLoader.Loader(this.resources, this);\n  this.textLoader = new textLoader.TextLoader(this.resources);\n  let options = this.env.getOptions();\n  this.numFrames = options.num_frames || -1;\n  if (options.display) {\n    this.useDisplay(options.display);\n  }\n  this.display.initialize();\n  if (options.colors) {\n    this.useColors(options.colors);\n  }\n  if (options.zoom) {\n    this.setZoom(options.zoom);\n  }\n}\n\nScene.prototype._addMethods = function() {\n  let self = this;\n  let d = new drawing.Drawing();\n  let methods = d.getMethods();\n  for (let i = 0; i < methods.length; i++) {\n    let [fname, paramSpec, converter, impl] = methods[i];\n    this[fname] = function() {\n      let args = Array.from(arguments);\n      if (paramSpec === undefined) {\n        throw new Error(`function ${fname} does not have parameter spec`);\n      }\n      let realArgs = destructure.from(fname, paramSpec, args, converter);\n      if (self._config.translateCenter) {\n        self._translateArguments(paramSpec, realArgs);\n      }\n      self.aPlane[fname].apply(self.aPlane, realArgs);\n    }\n  }\n}\n\nScene.prototype._removeMethods = function() {\n  let self = this;\n  let d = new drawing.Drawing();\n  let methods = d.getMethods();\n  for (let i = 0; i < methods.length; i++) {\n    let [fname, paramSpec, converter, impl] = methods[i];\n    delete this[fname];\n  }\n}\n\nScene.prototype._translateArguments = function(params, args) {\n  let midX = this.aPlane.width / 2;\n  let midY = this.aPlane.height / 2;\n  for (let i = 0; i < params.length; i++) {\n    let param = params[i];\n    let arg = args[i];\n    if (param.startsWith('x')) {\n      if (args[i] === undefined) {\n        args[i] = 0;\n      }\n      args[i] += midX;\n    }\n    if (param.startsWith('y')) {\n      if (args[i] === undefined) {\n        args[i] = 0;\n      }\n      args[i] += midY;\n    }\n  }\n}\n\nScene.prototype.setSize = function(w, h) {\n  this._config.width = w;\n  this._config.height = h;\n  if (this.aPlane.width == 0 || this.aPlane.height == 0) {\n    this.aPlane.setSize(w, h);\n  }\n}\n\nScene.prototype.setScrollX = function(x) {\n  this._config.scrollX = Math.floor(x);\n}\n\nScene.prototype.setScrollY = function(y) {\n  this._config.scrollY = Math.floor(y);\n}\n\nScene.prototype.resetState = function() {\n  this.colorSet.clear();\n  this.aPlane.clear();\n  this.renderer.clear();\n  this.palette = null;\n  this.tiles = null;\n  this.attrs = null;\n  this.interrupts = null;\n  this.rgbBuffer = null;\n  this._config = {};\n  this._config.zoomScale = 1;\n  this._config.usingNonPrimaryPlane = false;\n  this._addMethods();\n}\n\nScene.prototype.then = function(cb) {\n  this.imgLoader.resolveAll(cb);\n}\n\nScene.prototype.setZoom = function(scale) {\n  this._config.zoomScale = scale;\n}\n\nScene.prototype.setTitle = function(title) {\n  this._config.titleText = title;\n}\n\nScene.prototype.originAtCenter = function() {\n  this._config.translateCenter = true;\n}\n\nScene.prototype.useColors = function(obj) {\n  return this.colorSet.use(obj);\n}\n\nScene.prototype.appendColors = function(obj) {\n  return this.colorSet.append(obj);\n}\n\nScene.prototype.numColors = function() {\n  return this.colorSet.size();\n}\n\nScene.prototype.useDisplay = function(nameOrDisplay) {\n  if (nameOrDisplay == 'ascii') {\n    this.display = new displayAscii.DisplayAscii();\n  } else if (this.isDisplayObject(nameOrDisplay)) {\n    this.display = nameOrDisplay;\n  } else {\n    throw new Error(`Invalid display ${JSON.stringify(nameOrDisplay)}`);\n  }\n  this.display.initialize();\n}\n\nScene.prototype.loadImage = function(filepath, opt) {\n  return this.imgLoader.loadImage(filepath, opt);\n}\n\nScene.prototype.select = function(x, y, w, h) {\n  let make = this.aPlane.clone();\n  make.offsetLeft = x;\n  make.offsetTop = y;\n  make.width = w;\n  make.height = h;\n  make._addMethods(true);\n  return make;\n}\n\nScene.prototype._doRender = function(num, exitAfter, drawFunc, betweenFunc, finalFunc) {\n  let plane = this.aPlane;\n  this.renderer.plane = plane;\n  this.renderer.configure(this);\n  let self = this;\n  if (!self._config.width || !self._config.height) {\n    if (!this.tiles) {\n      self._config.width = plane.width;\n      self._config.height = plane.height;\n    } else {\n      self._config.width = plane.width * this.tiles.tileWidth;\n      self._config.height = plane.height * this.tiles.tileHeight;\n    }\n  }\n  this.then(function() {\n    self.display.setSize(self._config.width, self._config.height);\n    self.display.setSource(self.renderer, self._config.zoomScale);\n    self.display.renderLoop(function() {\n      if (drawFunc) {\n        try {\n          drawFunc();\n        } catch(e) {\n          console.log(e);\n          throw e;\n        }\n      }\n      if (betweenFunc) {\n        betweenFunc();\n      }\n    }, num, exitAfter, finalFunc);\n  });\n}\n\nScene.prototype.show = function(finalFunc) {\n  this._doRender(1, false, null, null, finalFunc);\n}\n\nScene.prototype.run = function(drawFunc, betweenFrameFunc) {\n  this._doRender(this.numFrames, true, drawFunc, betweenFrameFunc, null);\n}\n\nScene.prototype.save = function(savepath) {\n  let res = this.renderPrimaryPlane();\n  let saveService = this.saveService;\n  if (!saveService) {\n    throw new Error('cannot save plane without save service');\n  }\n  saveService.saveTo(savepath, res.buff, res.width, res.height, res.pitch);\n}\n\nScene.prototype.renderPrimaryPlane = function() {\n  let pl = this.aPlane;\n  pl._prepare();\n  this.renderer.plane = pl;\n  this.renderer.configure(this);\n  let [width, height] = this.renderer.size();\n  let buff = this.renderer.render();\n  let pitch = pl.width*4;\n  if (buff.pitch) {\n    pitch = buff.pitch;\n  }\n  return {\n    buff:   buff,\n    width:  width,\n    height: height,\n    pitch:  pitch,\n  };\n}\n\nScene.prototype.quit = function() {\n  this.display.appQuit();\n}\n\nScene.prototype.nextFrame = function() {\n  this.aPlane.nextFrame();\n}\n\nScene.prototype.makeShape = function(method, params) {\n  if (method == 'polygon') {\n    let pointsOrPolygon = params[0];\n    return geometry.convertToPolygon(pointsOrPolygon);\n  } else if (method == 'rotate') {\n    let [pointsOrPolygon, angle] = params;\n    let polygon = geometry.convertToPolygon(pointsOrPolygon);\n    polygon.rotate(angle);\n    return polygon;\n  } else if (method == 'load') {\n    let [filepath, opt] = params;\n    opt = opt || {};\n    return this.loadImage(filepath, opt);\n  }\n}\n\nScene.prototype.setFont = function(spec) {\n  if (spec.startsWith('font:')) {\n    let name = spec.split(':')[1];\n    this.font = this.textLoader.createFontResource(name);\n    return;\n  }\n  let filename = spec;\n  this.font = this.textLoader.loadFont(filename);\n}\n\nScene.prototype.setTileset = function(which) {\n  if (which < 0 || which >= this.tilesetBanks.length) {\n    throw new Error(`invalid tileset number ${which}`);\n  }\n  this.tiles = this.tilesetBanks[which];\n  this.renderer.tiles = this.tiles;\n}\n\nScene.prototype.handleEvent = function(eventName, callback) {\n  this.display.handleEvent(eventName, callback);\n}\n\nScene.prototype.isDisplayObject = function(obj) {\n  let needMethods = ['initialize', 'setSize', 'setSource', 'renderLoop'];\n  for (let i = 0; i < needMethods.length; i++) {\n    let method = obj[needMethods[i]];\n    if (!method || typeof method != 'function') {\n      return false;\n    }\n  }\n  return true;\n}\n\nScene.prototype.getPaletteEntry = function(x, y) {\n  let c = this.aPlane.get(x, y);\n  this._ensurePalette();\n  return this.palette.get(c);\n}\n\nScene.prototype.getPaletteAll = function(opt) {\n  this._ensurePalette();\n  if (opt.sort) {\n    let remap = {};\n    let vals = [];\n    for (let i = 0; i < this.palette.length; i++) {\n      let rgb = this.palette[i].rgb;\n      remap[rgb.toInt()] = i;\n      vals.push(rgb);\n    }\n    // Remove the first color, treat it as the background\n    let bgColor = vals[0];\n    vals = vals.slice(1);\n    // Sort by HSV\n    vals = algorithm.sortByHSV(vals);\n    // Put the background color in front\n    vals = [bgColor].concat(vals);\n    // Build the palette items\n    let recolor = {};\n    let items = [];\n    for (let i = 0; i < vals.length; i++) {\n      let orig = remap[vals[i].toInt()];\n      let ent = new palette.PaletteEntry(vals[i], i, this.colorSet);\n      ent.cval = orig;\n      let reset = this.colorSet.get(ent.cval);\n      rgbColor.ensureIs(reset);\n      ent.rgb = reset;\n      recolor[orig] = i;\n      items.push(ent);\n    }\n    // Remap the colors in the data buffer\n    let pl = this.aPlane;\n    for (let y = 0; y < pl.height; y++) {\n      for (let x = 0; x < pl.width; x++) {\n        let k = pl.pitch * y + x;\n        let c = pl.data[k];\n        pl.data[k] = recolor[c];\n      }\n    }\n    // Assigin the palette to the scene\n    let saveService = this.saveService;\n    let pal = new palette.PaletteCollection(items, saveService);\n    this.palette = pal;\n  }\n  return this.palette;\n}\n\nScene.prototype._ensurePalette = function() {\n  if (this.palette == null) {\n    let colors = this.colorSet;\n    let saveService = this.saveService;\n    let all = [];\n    for (let i = 0; i < colors.size(); i++) {\n      let rgb = colors.get(i);\n      rgbColor.ensureIs(rgb);\n      let ent = new palette.PaletteEntry(rgb, i, colors);\n      all.push(ent);\n    }\n    this.palette = new palette.PaletteCollection(all, saveService);\n  }\n}\n\nScene.prototype.usePalette = function(vals) {\n  let colors = this.colorSet;\n  let saveService = this.saveService;\n  let all = [];\n  let ent;\n  for (let i = 0; i < vals.length; i++) {\n    let cval = vals[i];\n    if (cval === null) {\n      let rgb = new rgbColor.RGBColor(0);\n      ent = new palette.PaletteEntry(rgb, -1, colors);\n      ent.isAvail = true;\n      all.push(ent);\n      continue;\n    }\n    if (cval >= colors.size()) {\n      throw new Error(`illegal color value ${cval}, colorSet only has ${colors.size()}`);\n    }\n    let rgb = colors.get(cval);\n    rgbColor.ensureIs(rgb);\n    ent = new palette.PaletteEntry(rgb, cval, colors);\n    all.push(ent);\n  }\n  this.palette = new palette.PaletteCollection(all, saveService);\n}\n\nScene.prototype.useTileset = function(imgOrTileset, sizeInfo) {\n  if (imgOrTileset.constructor.name == 'Tileset') {\n    this.tiles = imgOrTileset;\n  } else if (Array.isArray(imgOrTileset)) {\n    // TODO: list of Tileset objects\n    let imageList = imgOrTileset;\n    let allBanks = [];\n    for (let i = 0; i < imageList.length; i++) {\n      let tileset = new tiles.Tileset(imageList[i], sizeInfo);\n      allBanks.push(tileset);\n    }\n    this.tilesetBanks = allBanks;\n    this.tiles = allBanks[0];\n  } else {\n    // TODO: assume this is a Plane\n    let img = imgOrTileset;\n    this.tiles = new tiles.Tileset(img, sizeInfo);\n  }\n  if (this.attrs) {\n    this.attrs.ensureConsistentTileset(this.tiles, this.palette);\n  }\n}\n\nScene.prototype.useAttributes = function(pl, sizeInfo) {\n  if (!this.palette) {\n    throw new Error('cannot useAttributes without a palette');\n  }\n  // TODO: validate sizeInfo\n  this.attrs = new attributes.Attributes(pl, sizeInfo);\n  if (this.tiles) {\n    this.attrs.ensureConsistentTileset(this.tiles, this.palette);\n  }\n}\n\nScene.prototype.useInterrupts = function(conf) {\n  if (!Array.isArray(conf)) {\n    throw new Error(`useInterrupts param must be an array`);\n  }\n  let renderPoint = -1;\n  for (let k = 0; k < conf.length; k++) {\n    let elem = conf[k];\n    if (elem.scanline === undefined) {\n      throw new Error(`useInterrupts element ${k} missing field 'scanline'`);\n    }\n    if (elem.scanline.constructor.name != 'Number') {\n      throw new Error(`useInterrupts element ${k}.scanline must be number`);\n    }\n    if (!elem.irq) {\n      throw new Error(`useInterrupts element ${k} missing field 'irq'`);\n    }\n    if (elem.irq.constructor.name != 'Function') {\n      throw new Error(`useInterrupts element ${k}.irq must be function`);\n    }\n    if (elem.scanline < renderPoint) {\n      throw new Error(`useInterrupts element ${k}.scanline larger than ${renderPoint}`);\n    }\n    renderPoint = elem.scanline;\n  }\n  this.interrupts = conf;\n}\n\nmodule.exports.Scene = Scene;\n\n\n//# sourceURL=webpack://raster/./src/scene.js?");

/***/ }),

/***/ "./src/text_loader.js":
/*!****************************!*\
  !*** ./src/text_loader.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const tinyFont = __webpack_require__(/*! ./font/tiny.js */ \"./src/font/tiny.js\");\n\nfunction TextLoader(resources) {\n  this.resources = resources;\n  return this;\n}\n\nTextLoader.prototype.loadFont = function(filename) {\n  let self = this;\n  let file = this.resources.openText(filename);\n  let font = {\n    file: file,\n    glyphs: null,\n  };\n  file.handleFileRead = function(content) {\n    font.glyphs = self.parseFont(content);\n  }\n  if (file.content) {\n    file.handleFileRead(file.content);\n  }\n  return font;\n}\n\nTextLoader.prototype.createFontResource = function(name) {\n  if (name != 'tiny') {\n    throw new Error(`only font:tiny is supported`);\n  }\n  let font = {\n    glyphs: null,\n  };\n  font.glyphs = this.parseFont(tinyFont.content);\n  return font;\n}\n\nTextLoader.prototype.parseFont = function(content) {\n  let font = {};\n\n  let labelRegex = /(\\w{2}):/;\n  let rowRegex = /\\t([-#]+)$/;\n\n  let currLabel = null;\n  let currGlyph = [];\n\n  let lines = content.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i];\n    if (line == '') {\n      font[currLabel] = currGlyph;\n      currLabel = null;\n      currGlyph = [];\n      continue;\n    }\n\n    if (!line.startsWith('\\t')) {\n      let found = line.match(labelRegex);\n      if (found) {\n        currLabel = found[1];\n        // Remove the label\n        line = line.slice(currLabel.length);\n      } else {\n        // TODO: Handle !found\n      }\n    }\n\n    let found = line.match(rowRegex);\n    if (found) {\n      let pixels = found[1];\n      currGlyph.push(pixels);\n    } else {\n      // TODO: Handle !found\n    }\n\n  }\n\n  return font;\n}\n\nmodule.exports.TextLoader = TextLoader;\n\n\n//# sourceURL=webpack://raster/./src/text_loader.js?");

/***/ }),

/***/ "./src/tiles.js":
/*!**********************!*\
  !*** ./src/tiles.js ***!
  \**********************/
/***/ ((module) => {

eval("function Tileset(sourceOrNum, sizeInfo) {\n  if (!sizeInfo) {\n    throw new Error(`Tileset requires a detail object parameter`);\n  }\n  if (!sizeInfo.tile_width) {\n    throw new Error(`invalid Tileset detail: missing tile_width`);\n  }\n  if (!sizeInfo.tile_height) {\n    throw new Error(`invalid Tileset detail: missing tile_height`);\n  }\n  if (!Math.trunc(sizeInfo.tile_width) != 0) {\n    throw new Error(`Tileset's tile_width must be integer`);\n  }\n  if (!Math.trunc(sizeInfo.tile_height) != 0) {\n    throw new Error(`Tileset's tile_height must be integer`);\n  }\n  if (sizeInfo.tile_width <= 0) {\n    throw new Error(`Tileset's tile_width must be > 0`);\n  }\n  if (sizeInfo.tile_height <= 0) {\n    throw new Error(`Tileset's tile_height must be > 0`);\n  }\n\n  if (typeof sourceOrNum == 'number') {\n    // construct a number of tiles\n    let num = sourceOrNum;\n    this.tileWidth = sizeInfo.tile_width;\n    this.tileHeight = sizeInfo.tile_height;\n    this._constructTiles(num);\n  } else if (isPlane(sourceOrNum)) {\n    // load tiles by aliasing their buffers to the source\n    let source = sourceOrNum;\n    if (sizeInfo.tile_width > source.width) {\n      throw new Error(`Tileset's tile_width is larger than source data`);\n    }\n    if (sizeInfo.tile_height > source.height) {\n      throw new Error(`Tileset's tile_height is larger than source data`);\n    }\n    this.tileWidth = sizeInfo.tile_width;\n    this.tileHeight = sizeInfo.tile_height;\n    this._loadTilesFromSource(source);\n  } else {\n    throw new Error(`invalid source: ${JSON.stringify(sourceOrNum)}`);\n  }\n\n  return this;\n}\n\nTileset.prototype.get = function(c) {\n  return this.data[c];\n}\n\nTileset.prototype._loadTilesFromSource = function(source) {\n  this.numTileX = source.width / this.tileWidth;\n  this.numTileY = source.height / this.tileHeight;\n  this.numTiles = this.numTileX * this.numTileY\n  this.data = new Array(this.numTiles);\n  // For each tile, load the data and create a tile object\n  for (let yTile = 0; yTile < this.numTileY; yTile++) {\n    for (let xTile = 0; xTile < this.numTileX; xTile++) {\n      let k = yTile * this.numTileX + xTile;\n      let t = new Tile();\n      t.width = this.tileWidth;\n      t.height = this.tileHeight;\n      t.pitch = source.pitch;\n      let offset = xTile * this.tileWidth + t.pitch * yTile * this.tileHeight;\n      // Alias the buffer's data, no copy happens\n      t.data = new Uint8Array(source.data.buffer, offset);\n      this.data[k] = t;\n    }\n  }\n}\n\nTileset.prototype._constructTiles = function(num) {\n  let pitch = this.tileWidth;\n  this.numTileX = num;\n  this.numTileY = 1;\n  this.numTiles = num;\n  this.data = new Array(num);\n  // For each tile, construct an empty buffer\n  for (let yTile = 0; yTile < this.numTileY; yTile++) {\n    for (let xTile = 0; xTile < this.numTileX; xTile++) {\n      let k = yTile * this.numTileX + xTile;\n      let t = new Tile();\n      t.width = this.tileWidth;\n      t.height = this.tileHeight;\n      t.pitch = pitch;\n      t.data = new Uint8Array(this.tileHeight * pitch);\n      this.data[k] = t;\n    }\n  }\n}\n\nTileset.prototype.display = function() {\n  for (let yTile = 0; yTile < this.numTileY; yTile++) {\n    for (let xTile = 0; xTile < this.numTileX; xTile++) {\n      let k = yTile * this.numTileX + xTile;\n      let t = this.data[k];\n      process.stdout.write(`Tile ${k}:\\n`);\n      for (let j = 0; j < this.tileHeight; j++) {\n        for (let i = 0; i < this.tileWidth; i++) {\n          let k = j*t.pitch + i;\n          let v = t.data[k].toString(16);\n          if (v.length < 2) {\n            v = '0' + v;\n          }\n          process.stdout.write(`${v} `);\n        }\n        process.stdout.write('\\n');\n      }\n      process.stdout.write('\\n');\n    }\n  }\n}\n\nfunction Tile() {\n  this.width = null;\n  this.height = null;\n  this.pitch = null;\n  this.data = null;\n  return this;\n}\n\nTile.prototype.get = function(x, y) {\n  let k = y * this.pitch + x;\n  return this.data[k];\n}\n\nTile.prototype.put = function(x, y, v) {\n  let k = y * this.pitch + x;\n  this.data[k] = v;\n}\n\nTile.prototype.display = function() {\n  for (let j = 0; j < this.height; j++) {\n    for (let i = 0; i < this.width; i++) {\n      let k = j*this.pitch + i;\n      let v = this.data[k].toString(16);\n      if (v.length < 2) {\n        v = '0' + v;\n      }\n      process.stdout.write(`${v} `);\n    }\n    process.stdout.write('\\n');\n  }\n}\n\n\nfunction isPlane(obj) {\n  return obj.constructor.name == 'Plane' || obj.constructor.name == 'ImagePlane';\n}\n\nmodule.exports.Tileset = Tileset;\n\n\n//# sourceURL=webpack://raster/./src/tiles.js?");

/***/ }),

/***/ "./src/web_env.js":
/*!************************!*\
  !*** ./src/web_env.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const displayWebGL = __webpack_require__(/*! ./display_webgl.js */ \"./src/display_webgl.js\");\nconst display2dCanvas = __webpack_require__(/*! ./display_2d_canvas.js */ \"./src/display_2d_canvas.js\");\nconst plane = __webpack_require__(/*! ./plane.js */ \"./src/plane.js\");\nconst resources = __webpack_require__(/*! ./resources.js */ \"./src/resources.js\");\n\nfunction makeResources() {\n  return new resources.Resources();\n}\n\nfunction makeDisplay() {\n  if (!runningUnderKarma() && detectFeatureWebGL()) {\n    return new displayWebGL.Display();\n  }\n  return new display2dCanvas.Display();\n}\n\nfunction getOptions() {\n  return {};\n}\n\nfunction detectFeatureWebGL() {\n  let canvas = document.createElement('canvas');\n  let gl = canvas.getContext('webgl');\n  if (gl) {\n    return true;\n  }\n  return false;\n}\n\nfunction runningUnderKarma() {\n  return window.__karma__ !== undefined;\n}\n\nmodule.exports.makeDisplay = makeDisplay;\nmodule.exports.makeResources = makeResources;\nmodule.exports.getOptions = getOptions;\n\n\n//# sourceURL=webpack://raster/./src/web_env.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;